# File Upload

When submitting HTML forms, the browser typically sends the provided data in a POST request with the content type `application/x-www-form-url-encoded`. This is fine for sending simple text like your name or address. However, it isn't suitable for sending large amounts of binary data, such as an entire image file or a PDF document. In this case, the content type `multipart/form-data` is preferred.

MIME Type (RFC 6838)



When testing a file upload form, we should always determine what happens when a file is uploaded twice:
- If the web application indicates that the file already exists, we can use this method to brute force the contents of a web server.
- Alternatively, if the web application displays an error message, this may provide valuable information such as the programming language or web technologies in use.




We can group File Upload vulnerabilities into three categories:
- vulnerabilities enabling us to upload files that are executable by the web application:
	Example: webshell `simple-backdoor.php`
	
- vulnerabilities that require us to combine the file upload mechanism with another vulnerability, such as Directory Traversal
	Example: if the web application is vulnerable to Directory Traversal, we can use a relative path in the file upload request and try to overwrite files like `authorized_keys`. Furthermore, we can also combine file upload mechanisms with XML External Entity (XXE) or Cross Site Scripting (XSS) attacks. For example, when we are allowed to upload an avatar to a profile with an SVG file type, we may embed an XXE attack to display file contents or even execute code.
	
- the third category relies on user interaction. For example, when we discover an upload form for job applications, we can try to upload a CV in `.docx` format with malicious macros integrated.


































## PHP
`<?php echo file_get_contents('/path/to/target/file'); ?>`
Once uploaded, sending a request for this malicious file will return the target file's contents in the response.

A more versatile web shell may look something like this:

`<?php echo system($_GET['command']); ?>`
`<?php echo system($_GET['cmd']); ?>`
This script enables you to pass an arbitrary system command via a query parameter as follows: `GET /example/exploit.php?command=id HTTP/1.1`

















## Using Non-Executable Files

Example:
Connect as root with our private key due to the overwritten authorized_keys file. Facing a scenario in which we can't use a file upload mechanism to upload executable files, we'll need to get creative to find other vectors we can leverage.

We should be aware, that blindly overwriting files in a real-life penetration test could result in lost data or costly downtime of a production system. 











