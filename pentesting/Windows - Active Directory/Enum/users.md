# Windows - Active Directory User Enumeration



It's not uncommon that the local Administrator accounts across computers in a domain are set up with the same password.



Win+R > lusrmgr.msc





```
whoami /user
whoami /priv
whoami /all

hostname

#Check which users exist locally on the system:
Get-LocalUser
```






#### `net.exe`
- We can use this tool to enumerate local accounts on the machine, we'll instead use `/domain` to print out the users in the domain.

```
# Print out the users in the domain
net user /domain

# Inspect a specific user
net user [USERNAME] /domain
```














Get-LocalUser | Format-Table Name, Enabled, LastLogon
net user john | findstr /B /C:"Last logon"

Get-LocalUser | Sort-Object -Property Enabled | Format-Table Name, Enabled, LastLogon
sl $env:SystemDrive/users # go to Users directory

# enable/disable the built-in Administrator:
net user administrator /active:yes
net user administrator /active:no

# add/delete user
net user "username" "p@ssw0rd" /add
net user "username" /delete


# list all SIDs on a system
gcim Win32_Account | ft Name, SID

# list all User SID
gcim Win32_UserAccount | ft Name, SID
Get-WmiObject win32_useraccount | Select name,sid


```

Get SID from User
```
$objUser = New-Object System.Security.Principal.NTAccount("DOMAIN_NAME", "USER_NAME")
$strSID = $objUser.Translate([System.Security.Principal.SecurityIdentifier])
$strSID.Value
```

Get User from SID
```
$objSID = New-Object System.Security.Principal.SecurityIdentifier S-1-5-21-455291304-1752063992-2633877976-1002
$objUser = $objSID.Translate( [System.Security.Principal.NTAccount])
$objUser.Value
```

Local user to SID
```
$objUser = New-Object System.Security.Principal.NTAccount(LOCAL_USER_NAME)
$strSID = $objUser.Translate([System.Security.Principal.SecurityIdentifier])
$strSID.Value
```

Open powershell as another user (1):
```
$username = 'username'
$password = 'password'
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword
Start-Process powershell.exe -Credential $credential
```

Open powershell as another user (2):
```
$credentialParams = @{
    UserName = 'username'
    Password = 'password' | ConvertTo-SecureString -AsPlainText -Force
}

$credential = New-Object System.Management.Automation.PSCredential @credentialParams

$processParams = @{
    FilePath = 'powershell.exe'
    Credential = $credential
}

Start-Process @processParams
```
















## PowerView

PowerView is a PowerShell tool to gain network situational awareness on Windows domains. It contains a set of pure-PowerShell replacements for various windows "net *" commands, which utilize PowerShell AD hooks and underlying Win32 API functions to perform useful Windows domain functionality.

Is part of PowerSploit.

- <https://powersploit.readthedocs.io/en/latest/Recon/>
- <https://book.hacktricks.xyz/windows-hardening/basic-powershell-for-pentesters/powerview>


List of all Users in the domain. `Get-NetUser` automatically enumerates all attributes on a the user objects:
```
Get-NetUser

Get-NetUser | select [ATTRIBUTE]
Get-NetUser | select cn


# find probable weak users
Get-NetUser | select cn,pwdlastset,lastlogon

```










## Logged users
`PsLoggedOn` from SysInternals Suite.

Will enumerate the registry keys under HKEY_USERS to retrieve the security identifiers (SID) of logged-in users and convert the SIDs to usernames.


One limitation is that `PsLoggedOn` relies on the Remote Registry service in order to scan the associated key. The Remote Registry service has not been enabled by default on Windows workstations since Windows, but system administrators may enable it for various administrative tasks, for backwards compatibility, or for installing monitoring/deployment tools, scripts, agents, etc.

```
PsLoggedon.exe [TARGET HOSTNAME]
.\PsLoggedon.exe \\<computername>

PsLoggedon.exe \\files04
```

Example output:
```
Users logged on locally:
	<unknown time>			CORP\jeffadmin
Users logged on via resource shares:
	10/5/2022 1:33:32 AM	CORP\stephanie
```
























# get IP
Get-NetComputer | ForEach-Object {
    $hostname = $_.dnshostname
    $ip = (Resolve-DnsName -Name $hostname | Where-Object { $_.QueryType -eq 'A' }).IPAddress
    [PSCustomObject]@{
        DNSHostName             = $hostname
        OperatingSystem         = $_.operatingsystem
        OperatingSystemVersion  = $_.operatingsystemversion
        IPAddress               = $ip
    }
} | Select-Object DNSHostName, OperatingSystem, OperatingSystemVersion, IPAddress


```



`Find-LocalAdminAccess` scans the network in an attempt to determine if our current user has administrative permissions on any computers in the domain. It relies on the `OpenServiceW` function which will connect to the Service Control Manager (SCM) on the target machines.

The SCM essentially maintains a database of installed services and drivers on Windows computers. PowerView will attempt to open this database with the `SC_MANAGER_ALL_ACCESS` access right, which require administrative privileges, and if the connection is successful, PowerView will deem that our current user has administrative privileges on the target machine.


Depending on the size of the environment, it may take a few minutes for `Find-LocalAdminAccess` to finish.

```
Find-LocalAdminAccess
Find-LocalAdminAccess -Domain dev.testlab.local


$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force
$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\dfm.a', $SecPassword)
Find-LocalAdminAccess -Domain testlab.local -Credential $Cred

```