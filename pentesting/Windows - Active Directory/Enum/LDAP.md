# LDAP

```
ldapsearch -x -H ldap://<IP>:<port> # try on both ldap and ldaps, this is first command to run if you dont have any valid credentials.

ldapsearch -x -H ldap://<IP> -D '' -w '' -b "DC=<1_SUBDOMAIN>,DC=<TLD>"
ldapsearch -x -H ldap://<IP> -D '<DOMAIN>\<username>' -w '<password>' -b "DC=<1_SUBDOMAIN>,DC=<TLD>"
#CN name describes the info w're collecting
ldapsearch -x -H ldap://<IP> -D '<DOMAIN>\<username>' -w '<password>' -b "CN=Users,DC=<1_SUBDOMAIN>,DC=<TLD>"
ldapsearch -x -H ldap://<IP> -D '<DOMAIN>\<username>' -w '<password>' -b "CN=Computers,DC=<1_SUBDOMAIN>,DC=<TLD>"
ldapsearch -x -H ldap://<IP> -D '<DOMAIN>\<username>' -w '<password>' -b "CN=Domain Admins,CN=Users,DC=<1_SUBDOMAIN>,DC=<TLD>"
ldapsearch -x -H ldap://<IP> -D '<DOMAIN>\<username>' -w '<password>' -b "CN=Domain Users,CN=Users,DC=<1_SUBDOMAIN>,DC=<TLD>"
ldapsearch -x -H ldap://<IP> -D '<DOMAIN>\<username>' -w '<password>' -b "CN=Enterprise Admins,CN=Users,DC=<1_SUBDOMAIN>,DC=<TLD>"
ldapsearch -x -H ldap://<IP> -D '<DOMAIN>\<username>' -w '<password>' -b "CN=Administrators,CN=Builtin,DC=<1_SUBDOMAIN>,DC=<TLD>"
ldapsearch -x -H ldap://<IP> -D '<DOMAIN>\<username>' -w '<password>' -b "CN=Remote Desktop Users,CN=Builtin,DC=<1_SUBDOMAIN>,DC=<TLD>"

#windapsearch.py
#for computers
python3 windapsearch.py --dc-ip <IP address> -u <username> -p <password> --computers

#for groups
python3 windapsearch.py --dc-ip <IP address> -u <username> -p <password> --groups

#for users
python3 windapsearch.py --dc-ip <IP address> -u <username> -p <password> --da

#for privileged users
python3 windapsearch.py --dc-ip <IP address> -u <username> -p <password> --privileged-users
```




#######################################

AD enumeration relies on LDAP.
When a domain machine searches for an object, like a printer, or when we query user or group objects, LDAP is used as the communication channel for the query.
In other words, LDAP is the protocol used to communicate with Active Directory.



We can leverage an Active Directory Services Interface (ADSI), a set of interfaces built on `COM`, as an LDAP provider.
According to Microsof's documentation, we need a specific LDAP `ADsPath` in order to communicate with the AD service. The LDAP pathâ€™s prototype looks like this:
```
LDAP://HostName:[PortNumber]/[DistinguishedName]
```
- Hostname can be a computer name, IP address or a domain name. Note that a domain may have multiple DCs, so setting the domain name could potentially resolve to the IP address of any DC in the domain. Here we should look for the PDC, we need to find the DC holding the `PdcRoleOwner` property.
- PortNumber is optional. Unless using non-default ports.
- DistinguishedName is a part of the LDAP path. Uniquely identifies an object in AD, including the domain itself. See: <https://learn.microsoft.com/en-us/previous-versions/windows/desktop/ldap/distinguished-names>

Example of Distinguished Name:
```
CN=Stephanie,CN=Users,DC=corp,DC=com
```
It's read from right to left.

CN: Common Name
DC: Domain Component (when we are referring to a Distinguished Name). Represents the top of an LDAP tree and is the Distinguished Name of the domain itself.




- <https://learn.microsoft.com/en-us/windows/win32/adsi/active-directory-service-interfaces-adsi>
- <https://learn.microsoft.com/en-us/windows/win32/com/com-objects-and-interfaces>













## Use .NET classes and ADSI to dynamically obtain the full LDAP path required for our enumeration. 

Also, we must bypass the execution policy `powershell -ep bypass`

```
# Obtain the hostname for the PDC and store the domain object in a variable
$domainObj = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()

# Extract the value from the PdcRoleOwner property
$PDC = $domainObj.PdcRoleOwner.Name

# Now, while we can also get the DN for the domain via the domain object, it does not follow the naming standard required by LDAP.
# So we use ADSI directly in PowerShell to retrieve the DN. Use two single quotes to indicate that the search starts at the top of the AD hierarchy.
# This returns the DN in the proper format for the LDAP path.
$DN = ([adsi]'').distinguishedName


# Assemble the pieces to build the full LDAP path
$LDAP = "LDAP://$PDC/$DN"

```

If this script works,we have successfully used .NET classes and ADSI to dynamically obtain the full LDAP path required for our enumeration.



- Adding Search Functionality
To do this, we will use two .NET classes that are located in the `System.DirectoryServices` namespace, more specifically the `DirectoryEntry` and `DirectorySearcher` classes.

```
# encapsulate the LDAP path
$direntry = New-Object System.DirectoryServices.DirectoryEntry($LDAP)

# The $dirsearcher variable contains the $direntry variable and uses the information as the SearchRoot, pointing to the top of the hierarchy where DirectorySearcher will run the FindAll() method

$dirsearcher = New-Object System.DirectoryServices.DirectorySearcher($direntry)

# Filter in order to not receive all objects in the entire domain.
$dirsearcher.filter="samAccountType=805306368"
# $dirsearcher.filter="name=jeffadmin"

$result = $dirsearcher.FindAll()


# we are very interested in the attributes of each object, which are stored in the Properties field

Foreach($obj in $result)
{
	Foreach($prop in $obj.Properties)
	{
		$prop
		# $prop.memberof
	}

	Write-Host "-------------------------------"
}


```




Another option is to use a function to add the required parameters via the command line.
To use the function, we have to import it to memory: `Import-Module .\function.ps1`

```
function LDAPSearch {
	param (
		[string]$LDAPQuery
	)
	$PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name

	$DistinguishedName = ([adsi]'').distinguishedName
	
	$DirectoryEntry = New-Object System.DirectoryServices.DirectoryEntry("LDAP://$PDC/$DistinguishedName")
	
	$DirectorySearcher = New-Object System.DirectoryServices.DirectorySearcher($DirectoryEntry, $LDAPQuery)
	
	return $DirectorySearcher.FindAll()
	
}
```


Within PowerShell, we can now use the LDAPSearch command (our declared function name) to obtain information from AD.

Example use:
```
LDAPSearch -LDAPQuery "(samAccountType=805306368)"

# We can also search directly for an Object Class, which is a component of AD that defines the object type. Use objectClass=group in this case to list all the groups in the domain

LDAPSearch -LDAPQuery "(objectclass=group)"
```


To enumerate every group available in the domain and also display the user members, we can pipe the output into a new variable and use a foreach loop that will print each property for a group. This allows us to select specific attributes we are interested in. For example, let's focus on the CN and member attributes:
```
foreach ($group in $(LDAPSearch -LDAPQuery "(objectCategory=group)")) {$group.properties | select {$_.cn}, {$_.member}}
```

Specify the Sales Department:
```
$sales = LDAPSearch -LDAPQuery "(&(objectCategory=group)(cn=Sales Department))"

$sales.properties.member
```




Interesting filters:
- admincount
- cn
- lockouttime
- memberof
- objectguid
- objectsid
- primarygroupid
- samaccountname
- samaccounttype
- whenchanged
