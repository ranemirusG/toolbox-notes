# Active Directory Enumeration

Given that Active Directory contains a wealth of information, enumerating it is a critical step during a penetration test.

An AD environment has a critical dependency on the Domain Name System (DNS) service. As such, a typical domain controller will also host a DNS server that is authoritative for a given domain.

One or more Domain Controllers act as the hub and core of the domain, storing all OUs, objects, and their attributes.

We should look for the DC that holds the most updated information. This is known a as the Primary Domain Controller (PDC).
*There can be only one PDC in a domain.*
To find the PDC, we need to find the DC holding the `PdcRoleOwner` property.





## LDAP

AD enumeration relies on LDAP.
When a domain machine searches for an object, like a printer, or when we query user or group objects, LDAP is used as the communication channel for the query.
In other words, LDAP is the protocol used to communicate with Active Directory.



We can leverage an Active Directory Services Interface (ADSI), a set of interfaces built on `COM`, as an LDAP provider.
According to Microsof's documentation, we need a specific LDAP `ADsPath` in order to communicate with the AD service. The LDAP pathâ€™s prototype looks like this:
```
LDAP://HostName:[PortNumber]/[DistinguishedName]
```
- Hostname can be a computer name, IP address or a domain name. Note that a domain may have multiple DCs, so setting the domain name could potentially resolve to the IP address of any DC in the domain. Here we should look for the PDC, we need to find the DC holding the `PdcRoleOwner` property.
- PortNumber is optional. Unless using non-default ports.
- DistinguishedName is a part of the LDAP path. Uniquely identifies an object in AD, including the domain itself. See: <https://learn.microsoft.com/en-us/previous-versions/windows/desktop/ldap/distinguished-names>

Example of Distinguished Name:
```
CN=Stephanie,CN=Users,DC=corp,DC=com
```
It's read from right to left.

CN: Common Name
DC: Domain Component (when we are referring to a Distinguished Name). Represents the top of an LDAP tree and is the Distinguished Name of the domain itself.




- <https://learn.microsoft.com/en-us/windows/win32/adsi/active-directory-service-interfaces-adsi>
- <https://learn.microsoft.com/en-us/windows/win32/com/com-objects-and-interfaces>









## Targets

Attackers often target high-privileged groups.
Members of Domain Admins are among the most privileged objects in the domain.
If an attacker compromises a member of this group (often referred to as domain administrators), they essentially gain complete control over the domain.

This attack vector could extend beyond a single domain since an AD instance can host more than one domain in a domain tree or multiple domain trees in a domain forest.

While there is a Domain Admins group for each domain in the forest, members of the *Enterprise Admins* group are granted full control over all the domains in the forest and have Administrator privilege on all DCs. This is obviously a high-value target for an attacker.



















## Enumeration







### Using Legacy Windows Tools
AD contains so much information that it can be hard to determine where to start enumerating.

But since every AD installation fundamentally contains users and groups, we'll start there.

whoami /priv
hostname


#### `net.exe`
- We can use this tool to enumerate local accounts on the machine, we'll instead use `/domain` to print out the users in the domain.

```
# Print out the users in the domain
net user /domain

# Inspect a specific user
net user [USERNAME] /domain
```


- Enumerate groups
```
whoami /groups

net localgroup

net group /domain

net group [GROUP NAME] /domain
net group "Sales Department" /domain
```


- <https://learn.microsoft.com/en-us/windows-server/identity/ad-ds/manage/understand-security-groups>)



Enumerate each group, cataloging the results.


Members of `Domain Admin` are localadmin on all workstatiosn joined to the domain

Group Policies (and Group Policy Preferences) are stored in the SYSVOL share.









### Enumerating Active Directory using PowerShell and .NET Classes

PowerShell cmdlets like `Get-ADUser` work well but they are only installed by default on domain controllers as part of the Remote Server Administration Tools (RSAT).
RSAT is very rarely present on clients in a domain and we must have administrative privileges to install them. 

- <https://learn.microsoft.com/en-us/powershell/module/activedirectory/?view=windowsserver2022-ps>

```

# Check if Active Directory module is available
Get-Module -ListAvailable -Name ActiveDirectory

# List all AD Users
Get-ADUser -Filter * | Select-Object Name, SamAccountName

# List all AD Computers
Get-ADComputer -Filter * | Select-Object Name, OperatingSystem

# Create a New AD User
New-ADUser -Name "John Doe" -SamAccountName "jdoe" -UserPrincipalName "jdoe@yourdomain.com" -Path "OU=Users,DC=yourdomain,DC=com" -AccountPassword (Read-Host -AsSecureString "Enter Password") -Enabled $true

# Reset a User's Password
Set-ADAccountPassword -Identity "jdoe" -Reset -NewPassword (ConvertTo-SecureString -AsPlainText "NewPassword123" -Force)


# Check if a Computer is Active
Get-ADComputer -Filter 'Name -eq "ComputerName"' | Select-Object Name, Enabled







Get-ADDomain -Identity [domain]
Get-ADDomain -Current LocalComputer

Get-ADDomain
Get-ADDomain -Current LoggedOnUser

# Identify Your User DN (Distinguished Name)
(Get-ADUser -Identity YourUsername).DistinguishedName

# Search for all objects in the domain
$allObjects = Get-ADObject -Filter * -Properties ntSecurityDescriptor


Get-ADPrincipalGroupMembership [USERNAME]

# Retrieve the permissions for the object we define with the -Path flag 
Get-Acl -Path HKLM:SYSTEM\CurrentControlSet\Services\LanmanServer\DefaultSecurity\ | fl
```







- `GetCurrentDomain()` returns the domain object for the current user.
```
> [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()
...
PdcRoleOwner : DC1.corp.com
...
```





Script enumeration.ps1:

Use .NET classes and ADSI to dynamically obtain the full LDAP path required for our enumeration. 

Also, we must bypass the execution policy `powershell -ep bypass`

```
# Obtain the hostname for the PDC and store the domain object in a variable
$domainObj = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()

# Extract the value from the PdcRoleOwner property
$PDC = $domainObj.PdcRoleOwner.Name

# Now, while we can also get the DN for the domain via the domain object, it does not follow the naming standard required by LDAP.
# So we use ADSI directly in PowerShell to retrieve the DN. Use two single quotes to indicate that the search starts at the top of the AD hierarchy.
# This returns the DN in the proper format for the LDAP path.
$DN = ([adsi]'').distinguishedName


# Assemble the pieces to build the full LDAP path
$LDAP = "LDAP://$PDC/$DN"

```

If this script works,we have successfully used .NET classes and ADSI to dynamically obtain the full LDAP path required for our enumeration.



- Adding Search Functionality
To do this, we will use two .NET classes that are located in the `System.DirectoryServices` namespace, more specifically the `DirectoryEntry` and `DirectorySearcher` classes.

```
# encapsulate the LDAP path
$direntry = New-Object System.DirectoryServices.DirectoryEntry($LDAP)

# The $dirsearcher variable contains the $direntry variable and uses the information as the SearchRoot, pointing to the top of the hierarchy where DirectorySearcher will run the FindAll() method

$dirsearcher = New-Object System.DirectoryServices.DirectorySearcher($direntry)

# Filter in order to not receive all objects in the entire domain.
$dirsearcher.filter="samAccountType=805306368"
# $dirsearcher.filter="name=jeffadmin"

$result = $dirsearcher.FindAll()


# we are very interested in the attributes of each object, which are stored in the Properties field

Foreach($obj in $result)
{
	Foreach($prop in $obj.Properties)
	{
		$prop
		# $prop.memberof
	}

	Write-Host "-------------------------------"
}


```




Another option is to use a function to add the required parameters via the command line.
To use the function, we have to import it to memory: `Import-Module .\function.ps1`

```
function LDAPSearch {
	param (
		[string]$LDAPQuery
	)
	$PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name

	$DistinguishedName = ([adsi]'').distinguishedName
	
	$DirectoryEntry = New-Object System.DirectoryServices.DirectoryEntry("LDAP://$PDC/$DistinguishedName")
	
	$DirectorySearcher = New-Object System.DirectoryServices.DirectorySearcher($DirectoryEntry, $LDAPQuery)
	
	return $DirectorySearcher.FindAll()
	
}
```


Within PowerShell, we can now use the LDAPSearch command (our declared function name) to obtain information from AD.

Example use:
```
LDAPSearch -LDAPQuery "(samAccountType=805306368)"

# We can also search directly for an Object Class, which is a component of AD that defines the object type. Use objectClass=group in this case to list all the groups in the domain

LDAPSearch -LDAPQuery "(objectclass=group)"
```


To enumerate every group available in the domain and also display the user members, we can pipe the output into a new variable and use a foreach loop that will print each property for a group. This allows us to select specific attributes we are interested in. For example, let's focus on the CN and member attributes:
```
foreach ($group in $(LDAPSearch -LDAPQuery "(objectCategory=group)")) {$group.properties | select {$_.cn}, {$_.member}}
```

Specify the Sales Department:
```
$sales = LDAPSearch -LDAPQuery "(&(objectCategory=group)(cn=Sales Department))"

$sales.properties.member
```




Interesting filters:
- admincount
- cn
- lockouttime
- memberof
- objectguid
- objectsid
- primarygroupid
- samaccountname
- samaccounttype
- whenchanged

























### Enumeration with PowerView
PowerView is a PowerShell tool to gain network situational awareness on Windows domains. It contains a set of pure-PowerShell replacements for various windows "net *" commands, which utilize PowerShell AD hooks and underlying Win32 API functions to perform useful Windows domain functionality.

Is part of PowerSploit.

- <https://powersploit.readthedocs.io/en/latest/Recon/>
- <https://book.hacktricks.xyz/windows-hardening/basic-powershell-for-pentesters/powerview>


List of all Users in the domain. `Get-NetUser` automatically enumerates all attributes on a the user objects:
```
Get-NetUser

Get-NetUser | select [ATTRIBUTE]
Get-NetUser | select cn


# find probable weak users
Get-NetUser | select cn,pwdlastset,lastlogon

```


Similarly, we can use `Get-NetGroup` to enumerate groups:
```
Get-NetGroup
Get-NetGroup | select cn
Get-NetGroup | select samaccountname

Get-NetGroup "Sales Department" | select member
```




Enumerate computer objects in the domain
```
Get-NetComputer
Get-NetComputer | select dnshostname,operatingsystem,operatingsystemversion






# get IP
Get-NetComputer | ForEach-Object {
    $hostname = $_.dnshostname
    $ip = (Resolve-DnsName -Name $hostname | Where-Object { $_.QueryType -eq 'A' }).IPAddress
    [PSCustomObject]@{
        DNSHostName             = $hostname
        OperatingSystem         = $_.operatingsystem
        OperatingSystemVersion  = $_.operatingsystemversion
        IPAddress               = $ip
    }
} | Select-Object DNSHostName, OperatingSystem, OperatingSystemVersion, IPAddress


```




`Find-LocalAdminAccess` scans the network in an attempt to determine if our current user has administrative permissions on any computers in the domain. It relies on the `OpenServiceW` function which will connect to the Service Control Manager (SCM) on the target machines.

The SCM essentially maintains a database of installed services and drivers on Windows computers. PowerView will attempt to open this database with the `SC_MANAGER_ALL_ACCESS` access right, which require administrative privileges, and if the connection is successful, PowerView will deem that our current user has administrative privileges on the target machine.


Depending on the size of the environment, it may take a few minutes for `Find-LocalAdminAccess` to finish.

```
Find-LocalAdminAccess
Find-LocalAdminAccess -Domain dev.testlab.local


$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force
$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\dfm.a', $SecPassword)
Find-LocalAdminAccess -Domain testlab.local -Credential $Cred

```




#### More PowerView commands
```
Get-DomainController



Get-DomainComputer
Get-DomainComputer | select samaccountname, name



Get-DomainUser
Get-DomainUser -Identity [USERNAME]

# Identify users with "Do not require Kerberos preauthentication" enabled
# see AS-REP Roasting
Get-DomainUser -PreauthNotRequired


Get-DomainGroup | select name, member

Get-DomainGroupMember -Identity "Domain Admins"
Get-DomainGroupMember -Identity "Domain Admins" -Recurse


Get-NetLoggedon
# on local machine doesn't require to be local admin
Get-NetLoggedon | Select UserName
# For remote computers, you need privileges on that machine
Get-NetLoggedon -ComputerName DC01| Select UserName


Invoke-UserHunter -CheckAccess
# 1. get domain admins members
# 2. get list of computers
# 3. get-netloggedon and get-netsession on each computers
# 4. search if there is an active Domain Admin session in any computer
# 5. set if your user is a local admin on the machine that has the Domain Admin session
```












#### Obtain information as which user is logged in to which computer
Query a given host for active sessions

`Get-NetSession` command uses the NetWkstaUserEnum and NetSessionEnum APIs under the hood.
Works with older systems.

- <https://learn.microsoft.com/en-us/windows/win32/api/lmshare/nf-lmshare-netsessionenum>



```
Get-NetSession -ComputerName [COMPUTER NAME] -Verbose
Get-NetSession -ComputerName files04 -Verbose
```



`NetWkstaUserEnum1` requires administrative privileges
`NetSessionEnum` doesn't require admininstrative privileges 

The permissions required to enumerate sessions with NetSessionEnum are defined in the `SrvsvcSessionInfo` registry key, which is located in the `HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LanmanServer\DefaultSecurity` hive.
In order to view the permissions use the PowerShell `Get-Acl` cmdlet.






Another option is use `PsLoggedOn` from SysInternals Suite.

Will enumerate the registry keys under HKEY_USERS to retrieve the security identifiers (SID) of logged-in users and convert the SIDs to usernames.


One limitation is that `PsLoggedOn` relies on the Remote Registry service in order to scan the associated key. The Remote Registry service has not been enabled by default on Windows workstations since Windows, but system administrators may enable it for various administrative tasks, for backwards compatibility, or for installing monitoring/deployment tools, scripts, agents, etc.

```
PsLoggedon.exe [TARGET HOSTNAME]

PsLoggedon.exe \\files04
```

Example output:
```
Users logged on locally:
	<unknown time>			CORP\jeffadmin
Users logged on via resource shares:
	10/5/2022 1:33:32 AM	CORP\stephanie
```





















### Enumeration Through Service Principal Names
Continue our enumeration by focusing on a different type of user, more specifically Service Accounts.

Services launched by the system itself run in the context of a Service Account such as LocalSystem, LocalService and NetworkService.


When applications like Exchange,MS SQL, or Internet Information Services (IIS) are integrated into AD, a unique service instance identifier known as Service Principal Name (SPN) associates a service to a specific service account in Active Directory.

Service Principal Names (SPNs) are unique identifiers for services running on servers in an Active Directory (AD) environment. SPNs are used by Kerberos authentication to associate a service instance with a service logon account (like a user or computer account) in AD. This allows clients to locate and authenticate a specific service instance.

```
<service>/<hostname>:<port>/<service name>

MSSQLSvc/sqlserver.example.com:1433
```


Managed Service Accounts, introduced with Windows Server 2008 R2, were designed for complex applications, which require tighter integration with Active Directory.

- < https://learn.microsoft.com/en-us/windows-server/security/group-managed-service-accounts/group-managed-
service-accounts-overview>
 



We can obtain the IP address and port number of applications running on servers integrated with AD by simply enumerating all SPNs in the domain:

- `setspn.exe` (use `-L` to run against both servers and clients in the domain)

```
setspn -L iis_service
```

- With PowerView:
```
Get-NetUser -SPN | select samaccountname,serviceprincipalname
```

Then attempt to resolve the result with `nslookup.exe`:
```
nslookup.exe web04.corp.com
ping web04
Resolve-IpAddress CLIENT76.corp.com
```









impacket-GetUserSPNs active.htb/svc_tgs -dc-ip 10.10.10.100 -request
GetUserSPNs.py active.htb/svc_tgs -dc-ip 10.10.10.100 -request
















## Enumerate Object Permissions

An object in AD may have a set of permissions applied to it with multiple Access Control Entries (ACE).
These ACEs make up the Access Control List (ACL).
Each ACE defines whether access to the specific object is allowed or denied.

The ACL validation involves two main steps.

1. In an attempt to access the share, the user will send an access token, which consists of the user identity and permissions.

2. The target object will then validate the token against the list of permissions (the ACL). If the ACL allows the user to access the share, access is granted. Otherwise the request is denied.


AD includes a wealth of permission types that can be used to configure an ACE.
- <https://learn.microsoft.com/en-us/dotnet/api/system.directoryservices.activedirectoryrights?view=netframework-4.7.2>
- <https://learn.microsoft.com/en-us/windows/win32/secauthz/access-rights-and-access-masks>



However, from an attacker's standpoint, we are mainly interested in a few key permission types. Here is a list of the most interesting ones along with a description of the permissions they provide:
```
GenericAll: Full permissions on object
GenericWrite: Edit certain attributes on the object
WriteOwner: Change ownership of the object
WriteDACL: Edit ACE's applied to object
AllExtendedRights: Change password, reset password, etc.
ForceChangePassword: Password change for object
Self (Self-Membership): Add ourselves to for example a group
```


- Using PowerView
identify which security principals (users or groups) have full control (all permissions) over the given object

```
# enumerate our own user to determine which ACEs are applied to it
Get-ObjectAcl -Identity [USERNAME]
Get-ObjectAcl -Identity stephanie
```

Interesting properties:
- ObjectSID
- ActiveDirectoryRights (describes the type of permission applied to the object)
- SecurityIdentifier


<https://learn.microsoft.com/en-us/windows-server/identity/ad-ds/manage/understand-security-identifiers>



PowerView's `Convert-SidToName`
```
> Convert-SidToName S-1-5-21-1987370270-658905905-1781884369-1104
> CORP\stephanie
```



```
Get-ObjectAcl -Identity "robert" | 
    Where-Object { $_.ActiveDirectoryRights -eq "GenericAll" } |
    Select-Object -ExpandProperty SecurityIdentifier | 
    ForEach-Object { Convert-SidToName $_ }
```




My script!
```
<# 

Show AD permissions for objects with GenericAll rights.

@ranemirusG 2024
#>

# Define a hash table with permissions and their descriptions
$permissions = @{
    "GenericAll"            = "Full permissions on object"
    "GenericWrite"          = "Edit certain attributes on the object"
    "WriteOwner"            = "Change ownership of the object"
    "WriteDACL"             = "Edit ACE's applied to object"
    "AllExtendedRights"     = "Change password, reset password, etc."
    "ForceChangePassword"   = "Password change for object"
    "Self"                  = "Self-Membership: Add ourselves to, for example, a group"
}

# Initialize a hash table to store ObjectWithRights and associated users per permission
$objectRights = @{}

# Get the list of usernames and loop through each
Get-NetUser | Select-Object -ExpandProperty name | ForEach-Object {
    $username = $_
    
    # Loop through each permission
    foreach ($permission in $permissions.Keys) {
        # Run Get-ObjectAcl for the current username and filter for the specified rights
        $results = Get-ObjectAcl -Identity $username | 
            Where-Object { $_.ActiveDirectoryRights -eq $permission }
        
        # Process each result to build the hash table
        foreach ($result in $results) {
            # Convert SID to name
            $objectName = Convert-SidToName $result.SecurityIdentifier
            
            # Add to hash table or update it
            if (-not $objectRights.ContainsKey($objectName)) {
                $objectRights[$objectName] = @{}
            }
            if (-not $objectRights[$objectName].ContainsKey($permission)) {
                $objectRights[$objectName][$permission] = @($username)
            } else {
                $objectRights[$objectName][$permission] += $username
            }
        }
    }
}

# Output the results in a clear format
foreach ($object in $objectRights.Keys) {
    Write-Host "$object has the following permissions:"
    foreach ($permission in $objectRights[$object].Keys) {
        Write-Host "  - $permissions[$permission] ($permission):"
        foreach ($user in $objectRights[$object][$permission]) {
            Write-Host "    - $user"
        }
    }
    Write-Host "" # Add a blank line for better readability
}


```









Find-InterestingDomainAcl








## Enumerate Domain Shares

PowerView's  `Find-DomainShare` function to find the shares in the domain

Add the `-CheckShareAccess` flag to display shares only available to us


```
ls %SystemRoot%\SYSVOL\Sysvol\[DOMAIN NAME]\
ls \\dc1.corp.com\sysvol\corp.com\
```











### Enumerate domain joined machines

```
# Define the LDAP query
$LDAPFilter = "(&(objectCategory=computer)(objectClass=computer))"

# Use the DirectoryServices namespace to perform the search
$computers = [System.DirectoryServices.DirectorySearcher]::new($LDAPFilter)
$computers.FindAll() | ForEach-Object { $_.Properties["name"] }
```























## Automated Enumeration

### Collect domain data using SharpHound
- <https://bloodhound.readthedocs.io/en/latest/data-collection/sharphound.html>

SharpHound is written in C# and uses Windows API functions and LDAP namespace functions similar to those we used manually in the previous sections.
For example, SharpHound will attempt to use `NetWkstaUserEnum` and `NetSessionEnum` to enumerate logged-on sessions, just as we did earlier.
It will also run queries against the Remote Registry service, which we also leveraged earlier.

SharpHound is available in a few different formats. We can compile it ourselves, use an already compiled executable, or use it as a PowerShell script.

```
Import-Module .\Sharphound.ps1
```

In order to run SharpHound, we must first run Invoke-BloodHound


By default, SharpHound will gather the data in JSON files and automatically zip them for us. This makes it easy for us to transfer the file to Kali Linux later.
Example of output file with a "corp audit" prefix as shown below:
```
Invoke-BloodHound -CollectionMethod All -OutputDirectory C:\Users\stephanie\Desktop\ -OutputPrefix "corp audit"
```

- <https://bloodhound.readthedocs.io/en/latest/data-collection/sharphound-all-flags.html>




Sharphound created the `.bin` cache file to speed up data collection. This is not needed for our analysis and we can safely delete it.  








### Analyze the data using BloodHound
- <https://specterops.io/bloodhound-community-edition/>

In order to use BloodHound, we need to start the Neo4j.
Neo4j is essentially an open source graph database (NoSQL) that creates nodes, edges, and properties instead of simple rows and columns. This facilitates the visual representation of our collected data.
```
sudo neo4j start
```
Default username and password is "neo4j".






### neo4j

Delete databse:
```
MATCH (n)
DETACH DELETE n
```

- <https://neo4j.com/docs/cypher-manual/current/clauses/delete/>











































## Tools
- <https://directory.apache.org>
- <https://github.com/BloodHoundAD/BloodHound/releases>
- certipy <https://github.com/ly4k/Certipy>
