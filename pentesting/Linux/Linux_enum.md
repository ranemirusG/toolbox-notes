# Linux Enumeration



One of the first things we should identify is the user context.
```
id
```
The output reveals:
- the user we are operating as
- our User Identifier (UID)
- our Group Identifier (GID)
- wether we are also part of other groups




## Environment variables

```
.bashrc
env
```






## Enumerate all users
```
cat /etc/passwd
```






## Information about the operating system release and version
```
cat /etc/issue
cat /etc/*issue
cat /etc/os-release
cat /etc/*release

uname -r
uname -a

arch
```




## Running services
Explore which running processes and services may allow us to elevate our privileges. For this to occur, the process must run in the context of a privileged account and must either have insecure permissions or allow us to interact with it in unintended ways.

Unlike on Windows systems, on Linux we can list information about higher-privilege processes such as the ones running inside the root user context.



```
# "a" and "x" flags to list all processes with or without a tty and the "u" flag to list the processes in a user-readable format
ps aux

# run the ps command every second via the watch utility and grep the results on any occurrence of the word "pass"
watch -n 1 "ps -aux | grep pass"
```






## Network Interfaces / Routes / Open Ports

```
ifconfig
ifconfig -a

ip
ip a
ip addr

route
routel


netstat
netstat -antp
ss
ss -anp
ss -ntplu

```




### verify whether we have rights to capture network traffic

`tcpdump` is the de facto command line standard for packet capture, and it requires administrative access since it operates on raw sockets. 

It's common to find IT personnel accounts have been given exclusive access to this tool for troubleshooting purposes.

`tcpdump` cannot be run without `sudo` permissions. That is because it needs to set up raw sockets in order to capture traffic, which is a privileged operation.

Example:
Capture traffic in and out of the loopback interface, then dump its content in ASCII using the `-A` parameter and filter any traffic containing the "pass" keyword.
```
sudo tcpdump -i lo -A | grep "pass"
```



## Firewall Rules
In general, we're primarily interested in a firewall's state, profile, and rules during the remote exploitation phase of an assessment.
However, this information can also be useful during privilege escalation.
For example, if a network service is not remotely accessible because it is blocked by the firewall, it is generally accessible locally via the loopback interface. If we can interact with these services locally, we may be able to exploit them to escalate our privileges on the local system.

During this phase, we can also gather information about inbound and outbound port filtering to facilitate port forwarding and tunneling when it's time to pivot to an internal network.

On Linux-based systems, we must have root privileges to list firewall rules with `iptables`.
However, depending on how the firewall is configured, we may be able to glean information about the rules as a standard user.

Example:
```
joe@debian-privesc:~$ cat /etc/iptables/rules.v4
# Generated by xtables-save v1.8.2 on Thu Aug 18 12:53:22 2022
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -p tcp -m tcp --dport 1999 -j ACCEPT
COMMIT
# Completed on Thu Aug 18 12:53:22 2022

```
Since this file is read-only by any users other than root, we can inspect its contents. We'll notice a non-default rule that explicitly allows the destination `port 1999`. This configuration detail stands out and should be noted for later investigation.










## Scheduled Tasks
```
ls -lah /etc/cron*

# view the current user's scheduled jobs
crontab -l
sudo crontab -l
```










## Installed applications
- dpkg
```
dpkg -l
```











## File Permissions
```
# search for every directory writable by the current user
find / -writable -type d 2>/dev/null
```


### setuid and setgid

If these two rights are set, either an uppercase or lowercase "s" will appear in the permissions. This allows the current user to execute the file with the rights of the owner (setuid) or the owner's group (setgid).

When running an executable, it normally inherits the permissions of the user that runs it. However, if the SUID permissions are set, the binary will run with the permissions of the file owner. This means that if a binary has the SUID bit set and the file is owned by root, any local user will be able to execute that binary with elevated privileges.

When a user or a system-automated script launches a SUID application, it inherits the UID/GID of its initiating script: this is known as effective UID/GID (eUID, eGID), which is the actual user that the OS verifies to grant permissions for a given action.

Any user who manages to subvert a setuid root program to call a command of their choice can effectively impersonate the root user and gains all rights on the system. Penetration testers regularly search for these types of files when they gain access to a system as a way of escalating their privileges.

We can use `find` to search for SUID-marked binaries. In this case, we are starting our search at the root directory (/), searching for files (-type f) with the SUID bit set, (-perm -u=s) and discarding all error messages (2>/dev/null):

```
find / -perm -u=s -type f 2>/dev/null
```


If you discover an unusual SUID binary, you can try running the `strings` command on it to extract any readable text or strings.





### Linux Capabilities

Enumerate our target system for binaries with capabilities
```
/usr/sbin/getcap -r / 2>/dev/null
```





























## Drives
On most systems, drives are automatically mounted at boot time.
Because of this, it's easy to forget about unmounted drives that could contain valuable information.
We should always look for unmounted drives, and if they exist, check the mount permissions.

Use `mount` to list all mounted filesystems.

In addition, the `/etc/fstab` file lists all drives that will be mounted at boot time.


Keep in mind that the system administrator might have used custom configurations or scripts to mount drives that are not listed in the `/etc/fstab` file. Because of this, it's good practice to not only scan `/etc/fstab`, but to also gather information about mounted drives using `mount`.


Furthermore, we can use `lsblk` to view all available disks.






## Enumerate the loaded kernel modules
```
lsmod
```

Once we've collected the list of loaded modules and identified those we want more information about we can use modinfo to find out more about the specific module.

Note: this tool requires the full path to run.

Example with module `libata`:
```
/sbin/modinfo libata
```


Once we've obtained a list of drivers and their versions, we are better positioned to find any relevant exploits.
















## Automated Enumeration








### privesc-check

- <https://pentestmonkey.net/tools/audit/unix-privesc-check>
```
/usr/bin/unix-privesc-check
```













### LinPEAS

- <https://github.com/peass-ng/PEASS-ng/tree/master/linPEAS>

Enumerate and search Privilege Escalation vectors.

This tool enum and search possible misconfigurations (known vulns, user, processes and file permissions, special file permissions, readable/writable files, bruteforce other users(top1000pwds), passwords...) inside the host and highlight possible misconfigurations with colors.


Output to file:
```
./linpeas.sh -a > /dev/shm/linpeas.txt

# Read with colors
less -r /dev/shm/linpeas.txt
```


#### Flags

Checks:

`-a` Perform all checks: 1 min of processes, su brute, and extra checks.

`-o` Only execute selected checks (system_information,container,cloud,procs_crons_timers_srvcs_sockets,network_information,users_information,software_information,interesting_perms_files,interesting_files,api_keys_regex). Select a comma separated list.

`-s` Stealth & faster (don't check some time consuming checks)                                                                                    
`-e` Perform extra enumeration

`-t` Automatic network scan & Internet conectivity checks - This option writes to files                                                           
`-r` Enable Regexes (this can take from some mins to hours)                                                                                       
`-P` Indicate a password that will be used to run 'sudo -l' and to bruteforce other users accounts via 'su'     
                                  
`-D` Debug mode



Network recon:
                                                     
`-t` Automatic network scan & Internet conectivity checks - This option writes to files
                                                         
`-d` <IP/NETMASK> Discover hosts using fping or ping. Ex: -d 192.168.0.1/24                                      
                                 
`-p` <PORT(s)> -d <IP/NETMASK> Discover hosts looking for TCP open ports (via nc). By default ports 22,80,443,445,3389 and another one indicated by you will be scanned (select 22 if you don't want to add more). You can also add a list of ports. Ex: -d 192.168.0.1/24 -p 53,139
                     
`-i` <IP> [-p <PORT(s)>] Scan an IP using nc. By default (no -p), top1000 of nmap will be scanned, but you can select a list of ports instead. Ex: -i 127.0.0.1 -p 53,80,443,8000,8080                                                                                                                
Notice that if you specify some network scan (options -d/-p/-i but NOT -t), no PE check will be performed                                  
																																				
Port forwarding (reverse connection):

`-F` LOCAL_IP:LOCAL_PORT:REMOTE_IP:REMOTE_PORT Execute linpeas to forward a port from a your host (LOCAL_IP:LOCAL_PORT) to a remote IP (REMOTE_IP:REMOTE_PORT)                                                                                                                                                
																																				
Firmware recon:

`-f` </FOLDER/PATH> Execute linpeas to search passwords/file permissions misconfigs inside a folder                                               
																																				
Misc:                                                                                                                                               
`-h` To show this message                                                                                                                         
`-w` Wait execution between big blocks of checks                                                                                                  
`-L` Force linpeas execution                                                                                                                      
`-M` Force macpeas execution                                                                                                                      
`-q` Do not show banner                                                                                                                           
`-N` Do not use colours                                     




























### LinEnum
- <https://github.com/rebootuser/LinEnum>
